import 'dart:io';
import 'dart:typed_data';
import 'package:test/test.dart';
import 'package:kiwi_schema/kiwi.dart';

void main() {
  group('FigFile Parser', () {
    late Uint8List figFileData;

    setUpAll(() {
      // Load the canvas.fig file
      final file = File('${Directory.current.path}/../Apple_iOS_UI_Kit/canvas.fig');
      if (file.existsSync()) {
        figFileData = file.readAsBytesSync();
      } else {
        // Try relative path from test directory
        final altFile = File('${Directory.current.path}/../../Apple_iOS_UI_Kit/canvas.fig');
        if (altFile.existsSync()) {
          figFileData = altFile.readAsBytesSync();
        } else {
          throw Exception('canvas.fig not found. Run tests from dart directory.');
        }
      }
    });

    test('parses fig file structure', () {
      final figFile = parseFigFileStructure(figFileData);

      expect(figFile.header.prelude, equals('fig-kiwie'));
      expect(figFile.schemaChunk.data.length, equals(24208));
      expect(figFile.dataChunk.data.length, equals(3106170));
      expect(figFile.dataChunk.isZstd, isTrue);
      expect(figFile.schemaChunk.isDeflate, isTrue);
    });

    test('detects compression types correctly', () {
      // ZSTD signature
      final zstdData = Uint8List.fromList([0x28, 0xB5, 0x2F, 0xFD, 0x00]);
      expect(FigFileParser.detectCompression(zstdData), equals(CompressionType.zstd));

      // ZLIB signature (0x78 followed by valid second byte)
      final zlibData = Uint8List.fromList([0x78, 0x9C, 0x00, 0x00]);
      expect(FigFileParser.detectCompression(zlibData), equals(CompressionType.zlib));

      // Deflate when marked as schema chunk
      final deflateData = Uint8List.fromList([0xB5, 0xBD, 0x09, 0x98]);
      expect(FigFileParser.detectCompression(deflateData, isSchemaChunk: true),
             equals(CompressionType.deflate));

      // Unknown when not schema chunk and no known signature
      final unknownData = Uint8List.fromList([0x01, 0x02, 0x03, 0x04]);
      expect(FigFileParser.detectCompression(unknownData), equals(CompressionType.unknown));
    });

    test('FigHeader properties work correctly', () {
      final header = FigHeader(prelude: 'fig-kiwie', version: 0);
      expect(header.isFigKiwi, isTrue);
      expect(header.isFigJam, isFalse);

      final jamHeader = FigHeader(prelude: 'fig-jam.', version: 0);
      expect(jamHeader.isFigJam, isTrue);
      expect(jamHeader.isFigKiwi, isFalse);
    });
  });

  group('Binary Schema Decoding', () {
    late Uint8List schemaData;

    setUpAll(() {
      final file = File('${Directory.current.path}/test/fixtures/figma_schema.bin');
      if (file.existsSync()) {
        schemaData = file.readAsBytesSync();
      } else {
        throw Exception('figma_schema.bin not found');
      }
    });

    test('decodes binary schema', () {
      final schema = decodeBinarySchema(schemaData);

      expect(schema.definitions.length, greaterThan(100));

      // Check for expected types
      final defNames = schema.definitions.map((d) => d.name).toList();
      expect(defNames, contains('NodeType'));
      expect(defNames, contains('Message'));
      expect(defNames, contains('NodeChange'));
      expect(defNames, contains('Paint'));
      expect(defNames, contains('Effect'));
    });

    test('compiles decoded schema', () {
      final schema = decodeBinarySchema(schemaData);
      final compiled = compileSchema(schema);

      expect(compiled, isNotNull);

      // Check enum access
      final nodeTypes = compiled.getEnumValues('NodeType');
      expect(nodeTypes, isNotNull);
      // Figma's schema has different enum values than our predefined schema
      expect(nodeTypes!.containsKey('DOCUMENT'), isTrue);
      expect(nodeTypes.containsKey('FRAME'), isTrue);
      expect(nodeTypes.containsKey('TEXT'), isTrue);
    });

    test('schema has expected definitions', () {
      final schema = decodeBinarySchema(schemaData);

      // Find NodeChange definition
      final nodeChangeDef = schema.definitions.firstWhere(
        (d) => d.name == 'NodeChange',
        orElse: () => throw Exception('NodeChange not found'),
      );

      expect(nodeChangeDef.kind, equals(DefinitionKind.MESSAGE));
      expect(nodeChangeDef.fields.length, greaterThan(20));

      // Check some fields exist
      final fieldNames = nodeChangeDef.fields.map((f) => f.name).toList();
      expect(fieldNames, contains('guid'));
      expect(fieldNames, contains('type'));
      expect(fieldNames, contains('name'));
    });
  });

  group('Message Decoding', () {
    late Schema schema;
    late CompiledSchema compiledSchema;
    late Uint8List messageData;

    setUpAll(() {
      // Load schema
      final schemaFile = File('${Directory.current.path}/test/fixtures/figma_schema.bin');
      final schemaBytes = schemaFile.readAsBytesSync();
      schema = decodeBinarySchema(schemaBytes);
      compiledSchema = compileSchema(schema);

      // Load message sample (first 100KB)
      final messageFile = File('${Directory.current.path}/test/fixtures/figma_message_sample.bin');
      if (messageFile.existsSync()) {
        messageData = messageFile.readAsBytesSync();
      } else {
        throw Exception('figma_message_sample.bin not found');
      }
    });

    test('decodes message partially', () {
      // The sample is truncated so full decode will fail,
      // but we can verify the decoder starts correctly
      try {
        final message = compiledSchema.decode('Message', messageData);
        expect(message, isNotNull);
        expect(message['nodeChanges'], isNotNull);
      } catch (e) {
        // Expected - truncated data
        print('Partial decode (expected to fail): $e');
      }
    });
  });

  group('Full Message Decoding', () {
    late Schema schema;
    late CompiledSchema compiledSchema;
    late Uint8List messageData;

    setUpAll(() {
      // Load schema
      final schemaFile = File('${Directory.current.path}/test/fixtures/figma_schema.bin');
      final schemaBytes = schemaFile.readAsBytesSync();
      schema = decodeBinarySchema(schemaBytes);
      compiledSchema = compileSchema(schema);

      // Load full message
      final messageFile = File('${Directory.current.path}/test/fixtures/figma_message.bin');
      if (messageFile.existsSync()) {
        messageData = messageFile.readAsBytesSync();
      } else {
        throw Exception('figma_message.bin not found');
      }
    });

    test('decodes full message from Apple iOS UI Kit', () {
      final message = compiledSchema.decode('Message', messageData);

      expect(message, isNotNull);
      expect(message['nodeChanges'], isA<List>());

      final nodeChanges = message['nodeChanges'] as List;
      print('Total nodes: ${nodeChanges.length}');
      expect(nodeChanges.length, greaterThan(100));
    });

    test('finds document node', () {
      final message = compiledSchema.decode('Message', messageData);
      final nodeChanges = message['nodeChanges'] as List;

      final docNode = nodeChanges.firstWhere(
        (n) => n['type'] == 'DOCUMENT',
        orElse: () => null,
      );

      expect(docNode, isNotNull);
      expect(docNode['name'], equals('Document'));
    });

    test('finds canvas nodes', () {
      final message = compiledSchema.decode('Message', messageData);
      final nodeChanges = message['nodeChanges'] as List;

      final canvasNodes = nodeChanges.where((n) => n['type'] == 'CANVAS').toList();

      expect(canvasNodes.length, greaterThan(0));
      print('Canvas pages: ${canvasNodes.map((n) => n['name']).join(', ')}');
    });

    test('finds frame nodes', () {
      final message = compiledSchema.decode('Message', messageData);
      final nodeChanges = message['nodeChanges'] as List;

      final frameNodes = nodeChanges.where((n) => n['type'] == 'FRAME').toList();

      expect(frameNodes.length, greaterThan(0));
      print('Frames: ${frameNodes.length}');
    });

    test('finds text nodes', () {
      final message = compiledSchema.decode('Message', messageData);
      final nodeChanges = message['nodeChanges'] as List;

      final textNodes = nodeChanges.where((n) => n['type'] == 'TEXT').toList();

      expect(textNodes.length, greaterThan(0));
      print('Text nodes: ${textNodes.length}');

      // Check first text node has text data
      if (textNodes.isNotEmpty) {
        final textNode = textNodes.first;
        print('First text: ${textNode['name']}');
      }
    });

    test('finds component and instance nodes', () {
      final message = compiledSchema.decode('Message', messageData);
      final nodeChanges = message['nodeChanges'] as List;

      final componentNodes = nodeChanges.where((n) => n['type'] == 'COMPONENT').toList();
      final instanceNodes = nodeChanges.where((n) => n['type'] == 'INSTANCE').toList();

      print('Components: ${componentNodes.length}');
      print('Instances: ${instanceNodes.length}');
    });

    test('node count summary', () {
      final message = compiledSchema.decode('Message', messageData);
      final nodeChanges = message['nodeChanges'] as List;

      // Count by type
      final typeCounts = <String, int>{};
      for (final node in nodeChanges) {
        final type = node['type'] as String? ?? 'UNKNOWN';
        typeCounts[type] = (typeCounts[type] ?? 0) + 1;
      }

      print('\n=== Node Type Summary ===');
      final sortedTypes = typeCounts.entries.toList()
        ..sort((a, b) => b.value.compareTo(a.value));
      for (final entry in sortedTypes) {
        print('${entry.key}: ${entry.value}');
      }
      print('========================\n');
    });
  });
}

import 'package:test/test.dart';
import 'package:kiwi_schema/kiwi.dart';

void main() {
  group('Figma Schema', () {
    group('Schema Parsing', () {
      test('parses Figma schema successfully', () {
        expect(figmaSchema, isNotNull);
        expect(figmaSchema.definitions.length, greaterThan(50));
      });

      test('compiles Figma schema successfully', () {
        expect(compiledFigmaSchema, isNotNull);
      });

      test('has NodeType enum', () {
        final nodeTypes = figmaNodeTypeValues;
        expect(nodeTypes['NONE'], equals(0));
        expect(nodeTypes['DOCUMENT'], equals(1));
        expect(nodeTypes['CANVAS'], equals(2));
        expect(nodeTypes['FRAME'], equals(3));
        expect(nodeTypes['GROUP'], equals(4));
        expect(nodeTypes['VECTOR'], equals(5));
        expect(nodeTypes['RECTANGLE'], equals(10));
        expect(nodeTypes['TEXT'], equals(13));
        expect(nodeTypes['COMPONENT'], equals(38));
        expect(nodeTypes['INSTANCE'], equals(16));
      });

      test('has BlendMode enum', () {
        final blendModes = figmaBlendModeValues;
        expect(blendModes['PASS_THROUGH'], equals(0));
        expect(blendModes['NORMAL'], equals(1));
        expect(blendModes['MULTIPLY'], equals(3));
        expect(blendModes['SCREEN'], equals(6));
        expect(blendModes['OVERLAY'], equals(8));
      });

      test('has PaintType enum', () {
        final paintTypes = figmaPaintTypeValues;
        expect(paintTypes['SOLID'], equals(0));
        expect(paintTypes['GRADIENT_LINEAR'], equals(1));
        expect(paintTypes['GRADIENT_RADIAL'], equals(2));
        expect(paintTypes['IMAGE'], equals(5));
      });

      test('has EffectType enum', () {
        final effectTypes = figmaEffectTypeValues;
        expect(effectTypes['DROP_SHADOW'], equals(0));
        expect(effectTypes['INNER_SHADOW'], equals(1));
        expect(effectTypes['LAYER_BLUR'], equals(2));
        expect(effectTypes['BACKGROUND_BLUR'], equals(3));
      });
    });

    group('Paint Encoding/Decoding', () {
      test('encodes and decodes solid paint', () {
        final paint = {
          'type': 'SOLID',
          'color': {'r': 1.0, 'g': 0.5, 'b': 0.0, 'a': 1.0},
          'opacity': 1.0,
          'visible': true,
          'blendMode': 'NORMAL',
        };

        final encoded = encodeFigmaPaint(paint);
        expect(encoded, isNotEmpty);

        final decoded = decodeFigmaPaint(encoded);
        expect(decoded['type'], equals('SOLID'));
        expect(decoded['visible'], equals(true));
        expect(decoded['blendMode'], equals('NORMAL'));
        expect(decoded['color']['r'], equals(1.0));
        expect(decoded['color']['g'], equals(0.5));
        expect(decoded['color']['b'], equals(0.0));
        expect(decoded['color']['a'], equals(1.0));
      });

      test('encodes and decodes linear gradient paint', () {
        final paint = {
          'type': 'GRADIENT_LINEAR',
          'opacity': 0.8,
          'visible': true,
          'blendMode': 'MULTIPLY',
          'gradientStops': [
            {
              'position': 0.0,
              'color': {'r': 1.0, 'g': 0.0, 'b': 0.0, 'a': 1.0}
            },
            {
              'position': 1.0,
              'color': {'r': 0.0, 'g': 0.0, 'b': 1.0, 'a': 1.0}
            },
          ],
          'gradientTransform': {
            'handlePositionA': {'x': 0.0, 'y': 0.0},
            'handlePositionB': {'x': 1.0, 'y': 0.0},
            'handlePositionC': {'x': 0.0, 'y': 1.0},
          },
        };

        final encoded = encodeFigmaPaint(paint);
        final decoded = decodeFigmaPaint(encoded);

        expect(decoded['type'], equals('GRADIENT_LINEAR'));
        expect(decoded['opacity'], closeTo(0.8, 0.001));
        expect(decoded['gradientStops'], hasLength(2));
        expect(decoded['gradientStops'][0]['position'], equals(0.0));
        expect(decoded['gradientStops'][1]['position'], equals(1.0));
      });

      test('encodes and decodes image paint', () {
        final paint = {
          'type': 'IMAGE',
          'opacity': 1.0,
          'visible': true,
          'blendMode': 'NORMAL',
          'imageScaleMode': 'FILL',
          'imageSizeX': 100.0,
          'imageSizeY': 100.0,
          'imageTransform': {
            'm00': 1.0,
            'm01': 0.0,
            'm02': 0.0,
            'm10': 0.0,
            'm11': 1.0,
            'm12': 0.0
          },
        };

        final encoded = encodeFigmaPaint(paint);
        final decoded = decodeFigmaPaint(encoded);

        expect(decoded['type'], equals('IMAGE'));
        expect(decoded['imageScaleMode'], equals('FILL'));
        expect(decoded['imageSizeX'], equals(100.0));
      });
    });

    group('Effect Encoding/Decoding', () {
      test('encodes and decodes drop shadow', () {
        final effect = {
          'type': 'DROP_SHADOW',
          'visible': true,
          'color': {'r': 0.0, 'g': 0.0, 'b': 0.0, 'a': 0.25},
          'blendMode': 'NORMAL',
          'offset': {'x': 0.0, 'y': 4.0},
          'radius': 8.0,
          'spread': 0.0,
          'showShadowBehindNode': false,
        };

        final encoded = encodeFigmaEffect(effect);
        final decoded = decodeFigmaEffect(encoded);

        expect(decoded['type'], equals('DROP_SHADOW'));
        expect(decoded['visible'], equals(true));
        expect(decoded['offset']['x'], equals(0.0));
        expect(decoded['offset']['y'], equals(4.0));
        expect(decoded['radius'], equals(8.0));
      });

      test('encodes and decodes layer blur', () {
        final effect = {
          'type': 'LAYER_BLUR',
          'visible': true,
          'radius': 12.0,
        };

        final encoded = encodeFigmaEffect(effect);
        final decoded = decodeFigmaEffect(encoded);

        expect(decoded['type'], equals('LAYER_BLUR'));
        expect(decoded['radius'], equals(12.0));
      });
    });

    group('NodeChange Encoding/Decoding', () {
      test('encodes and decodes FRAME node', () {
        final frame = {
          'guid': {'sessionID': 1, 'localID': 100},
          'type': 'FRAME',
          'name': 'Test Frame',
          'visible': true,
          'locked': false,
          'opacity': 1.0,
          'blendMode': 'PASS_THROUGH',
          'size': {'width': 200.0, 'height': 100.0},
          'transform': {
            'm00': 1.0,
            'm01': 0.0,
            'm02': 50.0,
            'm10': 0.0,
            'm11': 1.0,
            'm12': 50.0
          },
          'clipsContent': true,
          'cornerRadius': 8.0,
          'cornerSmoothing': 0.6,
        };

        final encoded = encodeFigmaNodeChange(frame);
        final decoded = decodeFigmaNodeChange(encoded);

        expect(decoded['type'], equals('FRAME'));
        expect(decoded['name'], equals('Test Frame'));
        expect(decoded['visible'], equals(true));
        expect(decoded['size']['width'], equals(200.0));
        expect(decoded['size']['height'], equals(100.0));
        expect(decoded['cornerRadius'], equals(8.0));
      });

      test('encodes and decodes RECTANGLE node', () {
        final rect = {
          'guid': {'sessionID': 1, 'localID': 200},
          'type': 'RECTANGLE',
          'name': 'Background',
          'visible': true,
          'opacity': 1.0,
          'blendMode': 'NORMAL',
          'size': {'width': 100.0, 'height': 100.0},
          'transform': {
            'm00': 1.0,
            'm01': 0.0,
            'm02': 0.0,
            'm10': 0.0,
            'm11': 1.0,
            'm12': 0.0
          },
          'fillPaints': [
            {
              'type': 'SOLID',
              'color': {'r': 0.2, 'g': 0.4, 'b': 0.8, 'a': 1.0},
              'visible': true,
            }
          ],
          'strokeWeight': 2.0,
          'strokeAlign': 'INSIDE',
        };

        final encoded = encodeFigmaNodeChange(rect);
        final decoded = decodeFigmaNodeChange(encoded);

        expect(decoded['type'], equals('RECTANGLE'));
        expect(decoded['name'], equals('Background'));
        expect(decoded['fillPaints'], hasLength(1));
        expect(decoded['fillPaints'][0]['type'], equals('SOLID'));
        expect(decoded['strokeWeight'], equals(2.0));
        expect(decoded['strokeAlign'], equals('INSIDE'));
      });

      test('encodes and decodes TEXT node', () {
        final text = {
          'guid': {'sessionID': 1, 'localID': 300},
          'type': 'TEXT',
          'name': 'Title',
          'visible': true,
          'opacity': 1.0,
          'blendMode': 'NORMAL',
          'size': {'width': 200.0, 'height': 50.0},
          'transform': {
            'm00': 1.0,
            'm01': 0.0,
            'm02': 10.0,
            'm10': 0.0,
            'm11': 1.0,
            'm12': 10.0
          },
          'textData': {
            'characters': 'Hello, World!',
            'autoResize': 'WIDTH_AND_HEIGHT',
            'truncation': 'DISABLED',
            'maxLines': 0,
          },
        };

        final encoded = encodeFigmaNodeChange(text);
        final decoded = decodeFigmaNodeChange(encoded);

        expect(decoded['type'], equals('TEXT'));
        expect(decoded['textData']['characters'], equals('Hello, World!'));
        expect(decoded['textData']['autoResize'], equals('WIDTH_AND_HEIGHT'));
      });

      test('encodes and decodes VECTOR node', () {
        final vector = {
          'guid': {'sessionID': 1, 'localID': 400},
          'type': 'VECTOR',
          'name': 'Icon',
          'visible': true,
          'opacity': 1.0,
          'blendMode': 'NORMAL',
          'size': {'width': 24.0, 'height': 24.0},
          'transform': {
            'm00': 1.0,
            'm01': 0.0,
            'm02': 0.0,
            'm10': 0.0,
            'm11': 1.0,
            'm12': 0.0
          },
          'vectorData': {
            'vertices': [
              {
                'x': 0.0,
                'y': 0.0,
                'handleInX': 0.0,
                'handleInY': 0.0,
                'handleOutX': 0.0,
                'handleOutY': 0.0,
                'cornerRadius': 0.0,
                'handleMirroring': false,
              },
              {
                'x': 24.0,
                'y': 12.0,
                'handleInX': 0.0,
                'handleInY': 0.0,
                'handleOutX': 0.0,
                'handleOutY': 0.0,
                'cornerRadius': 0.0,
                'handleMirroring': false,
              },
              {
                'x': 0.0,
                'y': 24.0,
                'handleInX': 0.0,
                'handleInY': 0.0,
                'handleOutX': 0.0,
                'handleOutY': 0.0,
                'cornerRadius': 0.0,
                'handleMirroring': false,
              },
            ],
            'segments': [
              {
                'startVertex': 0,
                'endVertex': 1,
                'tangentStart': 0.0,
                'tangentEnd': 0.0,
              },
              {
                'startVertex': 1,
                'endVertex': 2,
                'tangentStart': 0.0,
                'tangentEnd': 0.0,
              },
              {
                'startVertex': 2,
                'endVertex': 0,
                'tangentStart': 0.0,
                'tangentEnd': 0.0,
              },
            ],
          },
        };

        final encoded = encodeFigmaNodeChange(vector);
        final decoded = decodeFigmaNodeChange(encoded);

        expect(decoded['type'], equals('VECTOR'));
        expect(decoded['vectorData']['vertices'], hasLength(3));
        expect(decoded['vectorData']['segments'], hasLength(3));
      });

      test('encodes and decodes ELLIPSE node with arc data', () {
        final ellipse = {
          'guid': {'sessionID': 1, 'localID': 500},
          'type': 'ELLIPSE',
          'name': 'Circle',
          'visible': true,
          'opacity': 1.0,
          'blendMode': 'NORMAL',
          'size': {'width': 100.0, 'height': 100.0},
          'transform': {
            'm00': 1.0,
            'm01': 0.0,
            'm02': 0.0,
            'm10': 0.0,
            'm11': 1.0,
            'm12': 0.0
          },
          'arcData': {
            'startingAngle': 0.0,
            'endingAngle': 6.283185307179586, // 2 * PI
            'innerRadius': 0.0,
          },
        };

        final encoded = encodeFigmaNodeChange(ellipse);
        final decoded = decodeFigmaNodeChange(encoded);

        expect(decoded['type'], equals('ELLIPSE'));
        expect(decoded['arcData']['startingAngle'], equals(0.0));
        expect(decoded['arcData']['innerRadius'], equals(0.0));
      });

      test('encodes and decodes STAR node', () {
        final star = {
          'guid': {'sessionID': 1, 'localID': 600},
          'type': 'STAR',
          'name': 'Star',
          'visible': true,
          'opacity': 1.0,
          'blendMode': 'NORMAL',
          'size': {'width': 100.0, 'height': 100.0},
          'transform': {
            'm00': 1.0,
            'm01': 0.0,
            'm02': 0.0,
            'm10': 0.0,
            'm11': 1.0,
            'm12': 0.0
          },
          'starPointCount': 5,
          'starInnerRadius': 0.4,
        };

        final encoded = encodeFigmaNodeChange(star);
        final decoded = decodeFigmaNodeChange(encoded);

        expect(decoded['type'], equals('STAR'));
        expect(decoded['starPointCount'], equals(5));
        expect(decoded['starInnerRadius'], closeTo(0.4, 0.001));
      });

      test('encodes and decodes COMPONENT node', () {
        final component = {
          'guid': {'sessionID': 1, 'localID': 700},
          'type': 'COMPONENT',
          'name': 'Button',
          'visible': true,
          'opacity': 1.0,
          'blendMode': 'PASS_THROUGH',
          'size': {'width': 120.0, 'height': 40.0},
          'transform': {
            'm00': 1.0,
            'm01': 0.0,
            'm02': 0.0,
            'm10': 0.0,
            'm11': 1.0,
            'm12': 0.0
          },
          'clipsContent': true,
          'cornerRadius': 20.0,
        };

        final encoded = encodeFigmaNodeChange(component);
        final decoded = decodeFigmaNodeChange(encoded);

        expect(decoded['type'], equals('COMPONENT'));
        expect(decoded['name'], equals('Button'));
        expect(decoded['cornerRadius'], equals(20.0));
      });

      test('encodes and decodes INSTANCE node', () {
        final instance = {
          'guid': {'sessionID': 1, 'localID': 800},
          'type': 'INSTANCE',
          'name': 'Button Instance',
          'visible': true,
          'opacity': 1.0,
          'blendMode': 'PASS_THROUGH',
          'size': {'width': 120.0, 'height': 40.0},
          'transform': {
            'm00': 1.0,
            'm01': 0.0,
            'm02': 200.0,
            'm10': 0.0,
            'm11': 1.0,
            'm12': 100.0
          },
          'componentID': {'sessionID': 1, 'localID': 700},
          'componentPropertyAssignments': [
            {'definitionID': 'label', 'value': 'Click Me'},
          ],
        };

        final encoded = encodeFigmaNodeChange(instance);
        final decoded = decodeFigmaNodeChange(encoded);

        expect(decoded['type'], equals('INSTANCE'));
        expect(decoded['componentID']['localID'], equals(700));
        expect(decoded['componentPropertyAssignments'], hasLength(1));
        expect(decoded['componentPropertyAssignments'][0]['value'],
            equals('Click Me'));
      });

      test('encodes and decodes node with auto-layout', () {
        final autoLayoutFrame = {
          'guid': {'sessionID': 1, 'localID': 900},
          'type': 'FRAME',
          'name': 'Auto Layout Frame',
          'visible': true,
          'opacity': 1.0,
          'blendMode': 'PASS_THROUGH',
          'size': {'width': 300.0, 'height': 200.0},
          'transform': {
            'm00': 1.0,
            'm01': 0.0,
            'm02': 0.0,
            'm10': 0.0,
            'm11': 1.0,
            'm12': 0.0
          },
          'clipsContent': true,
          'stackMode': 'VERTICAL',
          'stackPrimaryAlign': 'MIN',
          'stackCounterAlign': 'CENTER',
          'stackSpacing': 16.0,
          'stackPaddingTop': 24.0,
          'stackPaddingRight': 24.0,
          'stackPaddingBottom': 24.0,
          'stackPaddingLeft': 24.0,
          'stackPrimarySizing': 'RESIZE_TO_FIT',
          'stackCounterSizing': 'FIXED',
        };

        final encoded = encodeFigmaNodeChange(autoLayoutFrame);
        final decoded = decodeFigmaNodeChange(encoded);

        expect(decoded['stackMode'], equals('VERTICAL'));
        expect(decoded['stackPrimaryAlign'], equals('MIN'));
        expect(decoded['stackCounterAlign'], equals('CENTER'));
        expect(decoded['stackSpacing'], equals(16.0));
        expect(decoded['stackPaddingTop'], equals(24.0));
      });

      test('encodes and decodes node with effects', () {
        final nodeWithEffects = {
          'guid': {'sessionID': 1, 'localID': 1000},
          'type': 'RECTANGLE',
          'name': 'Card',
          'visible': true,
          'opacity': 1.0,
          'blendMode': 'NORMAL',
          'size': {'width': 200.0, 'height': 150.0},
          'transform': {
            'm00': 1.0,
            'm01': 0.0,
            'm02': 0.0,
            'm10': 0.0,
            'm11': 1.0,
            'm12': 0.0
          },
          'cornerRadius': 12.0,
          'effects': [
            {
              'type': 'DROP_SHADOW',
              'visible': true,
              'color': {'r': 0.0, 'g': 0.0, 'b': 0.0, 'a': 0.15},
              'blendMode': 'NORMAL',
              'offset': {'x': 0.0, 'y': 4.0},
              'radius': 16.0,
              'spread': 0.0,
            },
            {
              'type': 'DROP_SHADOW',
              'visible': true,
              'color': {'r': 0.0, 'g': 0.0, 'b': 0.0, 'a': 0.08},
              'blendMode': 'NORMAL',
              'offset': {'x': 0.0, 'y': 1.0},
              'radius': 4.0,
              'spread': 0.0,
            },
          ],
        };

        final encoded = encodeFigmaNodeChange(nodeWithEffects);
        final decoded = decodeFigmaNodeChange(encoded);

        expect(decoded['effects'], hasLength(2));
        expect(decoded['effects'][0]['type'], equals('DROP_SHADOW'));
        expect(decoded['effects'][0]['radius'], equals(16.0));
        expect(decoded['effects'][1]['radius'], equals(4.0));
      });

      test('encodes and decodes node with prototype interaction', () {
        final nodeWithInteraction = {
          'guid': {'sessionID': 1, 'localID': 1100},
          'type': 'RECTANGLE',
          'name': 'Button',
          'visible': true,
          'opacity': 1.0,
          'blendMode': 'NORMAL',
          'size': {'width': 100.0, 'height': 40.0},
          'transform': {
            'm00': 1.0,
            'm01': 0.0,
            'm02': 0.0,
            'm10': 0.0,
            'm11': 1.0,
            'm12': 0.0
          },
          'interactions': [
            {
              'trigger': 'ON_CLICK',
              'actions': [
                {
                  'navigationType': 'NAVIGATE',
                  'destinationID': {'sessionID': 1, 'localID': 2000},
                  'transition': {
                    'type': 'DISSOLVE',
                    'duration': 0.3,
                    'easingType': 'EASE_IN_OUT',
                  },
                  'preserveScrollPosition': false,
                },
              ],
              'delay': 0.0,
            },
          ],
        };

        final encoded = encodeFigmaNodeChange(nodeWithInteraction);
        final decoded = decodeFigmaNodeChange(encoded);

        expect(decoded['interactions'], hasLength(1));
        expect(decoded['interactions'][0]['trigger'], equals('ON_CLICK'));
        expect(decoded['interactions'][0]['actions'][0]['navigationType'],
            equals('NAVIGATE'));
        expect(decoded['interactions'][0]['actions'][0]['transition']['type'],
            equals('DISSOLVE'));
      });

      test('encodes and decodes BOOLEAN_OPERATION node', () {
        final boolOp = {
          'guid': {'sessionID': 1, 'localID': 1200},
          'type': 'BOOLEAN_OPERATION',
          'name': 'Union',
          'visible': true,
          'opacity': 1.0,
          'blendMode': 'NORMAL',
          'size': {'width': 100.0, 'height': 100.0},
          'transform': {
            'm00': 1.0,
            'm01': 0.0,
            'm02': 0.0,
            'm10': 0.0,
            'm11': 1.0,
            'm12': 0.0
          },
          'booleanOperation': 'UNION',
        };

        final encoded = encodeFigmaNodeChange(boolOp);
        final decoded = decodeFigmaNodeChange(encoded);

        expect(decoded['type'], equals('BOOLEAN_OPERATION'));
        expect(decoded['booleanOperation'], equals('UNION'));
      });

      test('encodes and decodes SECTION node', () {
        final section = {
          'guid': {'sessionID': 1, 'localID': 1300},
          'type': 'SECTION',
          'name': 'Design Section',
          'visible': true,
          'opacity': 1.0,
          'blendMode': 'PASS_THROUGH',
          'size': {'width': 1000.0, 'height': 800.0},
          'transform': {
            'm00': 1.0,
            'm01': 0.0,
            'm02': 0.0,
            'm10': 0.0,
            'm11': 1.0,
            'm12': 0.0
          },
        };

        final encoded = encodeFigmaNodeChange(section);
        final decoded = decodeFigmaNodeChange(encoded);

        expect(decoded['type'], equals('SECTION'));
        expect(decoded['name'], equals('Design Section'));
      });

      test('encodes and decodes GROUP node', () {
        final group = {
          'guid': {'sessionID': 1, 'localID': 1400},
          'type': 'GROUP',
          'name': 'Icon Group',
          'visible': true,
          'opacity': 0.8,
          'blendMode': 'NORMAL',
          'size': {'width': 48.0, 'height': 48.0},
          'transform': {
            'm00': 1.0,
            'm01': 0.0,
            'm02': 100.0,
            'm10': 0.0,
            'm11': 1.0,
            'm12': 100.0
          },
        };

        final encoded = encodeFigmaNodeChange(group);
        final decoded = decodeFigmaNodeChange(encoded);

        expect(decoded['type'], equals('GROUP'));
        expect(decoded['opacity'], closeTo(0.8, 0.001));
      });
    });

    group('Message Encoding/Decoding', () {
      test('encodes and decodes empty Message', () {
        final message = {
          'nodeChanges': <Map<String, dynamic>>[],
          'blobs': <Map<String, dynamic>>[],
          'blobBaseIndex': 0,
        };

        final encoded = encodeFigmaMessage(message);
        final decoded = decodeFigmaMessage(encoded);

        expect(decoded['nodeChanges'], isEmpty);
        expect(decoded['blobs'], isEmpty);
        expect(decoded['blobBaseIndex'], equals(0));
      });

      test('encodes and decodes Message with multiple nodes', () {
        final message = {
          'nodeChanges': [
            {
              'guid': {'sessionID': 1, 'localID': 1},
              'type': 'FRAME',
              'name': 'Frame 1',
              'visible': true,
              'size': {'width': 100.0, 'height': 100.0},
              'transform': {
                'm00': 1.0,
                'm01': 0.0,
                'm02': 0.0,
                'm10': 0.0,
                'm11': 1.0,
                'm12': 0.0
              },
            },
            {
              'guid': {'sessionID': 1, 'localID': 2},
              'type': 'RECTANGLE',
              'name': 'Rectangle 1',
              'visible': true,
              'size': {'width': 50.0, 'height': 50.0},
              'transform': {
                'm00': 1.0,
                'm01': 0.0,
                'm02': 25.0,
                'm10': 0.0,
                'm11': 1.0,
                'm12': 25.0
              },
            },
          ],
          'blobs': <Map<String, dynamic>>[],
          'blobBaseIndex': 0,
        };

        final encoded = encodeFigmaMessage(message);
        final decoded = decodeFigmaMessage(encoded);

        expect(decoded['nodeChanges'], hasLength(2));
        expect(decoded['nodeChanges'][0]['type'], equals('FRAME'));
        expect(decoded['nodeChanges'][1]['type'], equals('RECTANGLE'));
      });
    });

    group('Enum Name Resolution', () {
      test('resolves NodeType names correctly', () {
        final names = figmaNodeTypeNames;
        expect(names[0], equals('NONE'));
        expect(names[3], equals('FRAME'));
        expect(names[10], equals('RECTANGLE'));
        expect(names[13], equals('TEXT'));
      });

      test('resolves BlendMode names correctly', () {
        final names = figmaBlendModeNames;
        expect(names[0], equals('PASS_THROUGH'));
        expect(names[1], equals('NORMAL'));
        expect(names[3], equals('MULTIPLY'));
      });

      test('resolves PaintType names correctly', () {
        final names = figmaPaintTypeNames;
        expect(names[0], equals('SOLID'));
        expect(names[1], equals('GRADIENT_LINEAR'));
        expect(names[5], equals('IMAGE'));
      });
    });

    group('Binary Schema Encoding', () {
      test('encodes Figma schema to binary and decodes back', () {
        final binarySchema = encodeBinarySchema(figmaSchema);
        expect(binarySchema, isNotEmpty);

        final decodedSchema = decodeBinarySchema(binarySchema);
        expect(decodedSchema.definitions.length,
            equals(figmaSchema.definitions.length));
      });

      test('pretty prints Figma schema', () {
        final printed = prettyPrintSchema(figmaSchema);
        expect(printed, contains('enum NodeType'));
        expect(printed, contains('enum BlendMode'));
        expect(printed, contains('struct Color'));
        expect(printed, contains('message Paint'));
        expect(printed, contains('message NodeChange'));
      });
    });
  });
}

import 'dart:io';
import 'dart:typed_data';
import 'package:test/test.dart';
import 'package:kiwi_schema/kiwi.dart';

void main() {
  late String schemaText;
  late CompiledSchema schema;

  setUpAll(() {
    schemaText = File('test/test-schema.kiwi').readAsStringSync();
    schema = compileSchema(parseSchema(schemaText));
  });

  group('struct bool', () {
    void check(bool input, List<int> output) {
      expect(
        schema.encode('BoolStruct', {'x': input}),
        equals(Uint8List.fromList(output)),
      );
      expect(
        schema.decode('BoolStruct', Uint8List.fromList(output)),
        equals({'x': input}),
      );
    }

    test('false', () => check(false, [0]));
    test('true', () => check(true, [1]));
  });

  group('struct byte', () {
    void check(int input, List<int> output) {
      expect(
        schema.encode('ByteStruct', {'x': input}),
        equals(Uint8List.fromList(output)),
      );
      expect(
        schema.decode('ByteStruct', Uint8List.fromList(output)),
        equals({'x': input}),
      );
    }

    test('0x00', () => check(0x00, [0x00]));
    test('0x01', () => check(0x01, [0x01]));
    test('0x7F', () => check(0x7F, [0x7F]));
    test('0x80', () => check(0x80, [0x80]));
    test('0xFF', () => check(0xFF, [0xFF]));
  });

  group('struct uint', () {
    void check(int input, List<int> output) {
      expect(
        schema.encode('UintStruct', {'x': input}),
        equals(Uint8List.fromList(output)),
      );
      expect(
        schema.decode('UintStruct', Uint8List.fromList(output)),
        equals({'x': input}),
      );
    }

    test('0x00', () => check(0x00, [0x00]));
    test('0x01', () => check(0x01, [0x01]));
    test('0x02', () => check(0x02, [0x02]));
    test('0x7F', () => check(0x7F, [0x7F]));
    test('0x80', () => check(0x80, [0x80, 0x01]));
    test('0x81', () => check(0x81, [0x81, 0x01]));
    test('0x100', () => check(0x100, [0x80, 0x02]));
    test('0x101', () => check(0x101, [0x81, 0x02]));
    test('0x17F', () => check(0x17F, [0xFF, 0x02]));
    test('0x180', () => check(0x180, [0x80, 0x03]));
    test('0x1FF', () => check(0x1FF, [0xFF, 0x03]));
    test('0x200', () => check(0x200, [0x80, 0x04]));
    test('0x7FFF', () => check(0x7FFF, [0xFF, 0xFF, 0x01]));
    test('0x8000', () => check(0x8000, [0x80, 0x80, 0x02]));
    test('0x7FFFFFFF', () => check(0x7FFFFFFF, [0xFF, 0xFF, 0xFF, 0xFF, 0x07]));
    test('0x80000000', () => check(0x80000000, [0x80, 0x80, 0x80, 0x80, 0x08]));
  });

  group('struct int', () {
    void check(int input, List<int> output) {
      expect(
        schema.encode('IntStruct', {'x': input}),
        equals(Uint8List.fromList(output)),
      );
      expect(
        schema.decode('IntStruct', Uint8List.fromList(output)),
        equals({'x': input}),
      );
    }

    test('0x00', () => check(0x00, [0x00]));
    test('-0x01', () => check(-0x01, [0x01]));
    test('0x01', () => check(0x01, [0x02]));
    test('-0x02', () => check(-0x02, [0x03]));
    test('0x02', () => check(0x02, [0x04]));
    test('-0x3F', () => check(-0x3F, [0x7D]));
    test('0x3F', () => check(0x3F, [0x7E]));
    test('-0x40', () => check(-0x40, [0x7F]));
    test('0x40', () => check(0x40, [0x80, 0x01]));
    test('-0x3FFF', () => check(-0x3FFF, [0xFD, 0xFF, 0x01]));
    test('0x3FFF', () => check(0x3FFF, [0xFE, 0xFF, 0x01]));
    test('-0x4000', () => check(-0x4000, [0xFF, 0xFF, 0x01]));
    test('0x4000', () => check(0x4000, [0x80, 0x80, 0x02]));
    test('-0x3FFFFFFF', () => check(-0x3FFFFFFF, [0xFD, 0xFF, 0xFF, 0xFF, 0x07]));
    test('0x3FFFFFFF', () => check(0x3FFFFFFF, [0xFE, 0xFF, 0xFF, 0xFF, 0x07]));
    test('-0x40000000', () => check(-0x40000000, [0xFF, 0xFF, 0xFF, 0xFF, 0x07]));
    test('0x40000000', () => check(0x40000000, [0x80, 0x80, 0x80, 0x80, 0x08]));
    test('-0x7FFFFFFF', () => check(-0x7FFFFFFF, [0xFD, 0xFF, 0xFF, 0xFF, 0x0F]));
    test('0x7FFFFFFF', () => check(0x7FFFFFFF, [0xFE, 0xFF, 0xFF, 0xFF, 0x0F]));
    test('-0x80000000', () => check(-0x80000000, [0xFF, 0xFF, 0xFF, 0xFF, 0x0F]));
  });

  group('struct float', () {
    void check(double input, List<int> output) {
      var encoded = schema.encode('FloatStruct', {'x': input});
      expect(encoded, equals(Uint8List.fromList(output)));

      var decoded = schema.decode('FloatStruct', Uint8List.fromList(output));
      if (input.isNaN) {
        expect((decoded['x'] as double).isNaN, isTrue);
      } else {
        expect(decoded['x'], equals(input));
      }
    }

    test('0', () => check(0.0, [0]));
    test('1', () => check(1.0, [127, 0, 0, 0]));
    test('-1', () => check(-1.0, [127, 1, 0, 0]));
    test('3.1415927410125732', () => check(3.1415927410125732, [128, 182, 31, 146]));
    test('-3.1415927410125732', () => check(-3.1415927410125732, [128, 183, 31, 146]));
    test('Infinity', () => check(double.infinity, [255, 0, 0, 0]));
    test('-Infinity', () => check(double.negativeInfinity, [255, 1, 0, 0]));
    test('NaN', () => check(double.nan, [255, 0, 0, 128]));
  });

  group('struct string', () {
    void check(String input, List<int> output) {
      expect(
        schema.encode('StringStruct', {'x': input}),
        equals(Uint8List.fromList(output)),
      );
      expect(
        schema.decode('StringStruct', Uint8List.fromList(output)),
        equals({'x': input}),
      );
    }

    test('empty', () => check('', [0]));
    test('abc', () => check('abc', [97, 98, 99, 0]));
    test('emoji', () => check('ðŸ™‰ðŸ™ˆðŸ™Š', [240, 159, 153, 137, 240, 159, 153, 136, 240, 159, 153, 138, 0]));
  });

  group('struct compound', () {
    void check(Map<String, dynamic> input, List<int> output) {
      expect(
        schema.encode('CompoundStruct', input),
        equals(Uint8List.fromList(output)),
      );
      expect(
        schema.decode('CompoundStruct', Uint8List.fromList(output)),
        equals(input),
      );
    }

    test('zeros', () => check({'x': 0, 'y': 0}, [0, 0]));
    test('small', () => check({'x': 1, 'y': 2}, [1, 2]));
    test('large', () => check({'x': 12345, 'y': 54321}, [185, 96, 177, 168, 3]));
  });

  group('struct nested', () {
    void check(Map<String, dynamic> input, List<int> output) {
      expect(
        schema.encode('NestedStruct', input),
        equals(Uint8List.fromList(output)),
      );
      expect(
        schema.decode('NestedStruct', Uint8List.fromList(output)),
        equals(input),
      );
    }

    test('zeros', () => check({'a': 0, 'b': {'x': 0, 'y': 0}, 'c': 0}, [0, 0, 0, 0]));
    test('small', () => check({'a': 1, 'b': {'x': 2, 'y': 3}, 'c': 4}, [1, 2, 3, 4]));
    test('large', () => check({'a': 534, 'b': {'x': 12345, 'y': 54321}, 'c': 321}, [150, 4, 185, 96, 177, 168, 3, 193, 2]));
  });

  group('message bool', () {
    void check(Map<String, dynamic> input, List<int> output) {
      expect(
        schema.encode('BoolMessage', input),
        equals(Uint8List.fromList(output)),
      );
      expect(
        schema.decode('BoolMessage', Uint8List.fromList(output)),
        equals(input),
      );
    }

    test('empty', () => check({}, [0]));
    test('false', () => check({'x': false}, [1, 0, 0]));
    test('true', () => check({'x': true}, [1, 1, 0]));
  });

  group('message byte', () {
    void check(Map<String, dynamic> input, List<int> output) {
      expect(
        schema.encode('ByteMessage', input),
        equals(Uint8List.fromList(output)),
      );
      expect(
        schema.decode('ByteMessage', Uint8List.fromList(output)),
        equals(input),
      );
    }

    test('empty', () => check({}, [0]));
    test('value', () => check({'x': 234}, [1, 234, 0]));
  });

  group('struct byte array', () {
    void check(Map<String, dynamic> input, List<int> output) {
      var encoded = schema.encode('ByteArrayStruct', input);
      expect(encoded, equals(Uint8List.fromList(output)));

      var decoded = schema.decode('ByteArrayStruct', Uint8List.fromList(output));
      expect(decoded['x'], equals(input['x']));
    }

    test('empty', () => check({'x': Uint8List.fromList([])}, [0]));
    test('values', () => check({'x': Uint8List.fromList([4, 5, 6])}, [3, 4, 5, 6]));
  });

  group('message uint', () {
    void check(Map<String, dynamic> input, List<int> output) {
      expect(
        schema.encode('UintMessage', input),
        equals(Uint8List.fromList(output)),
      );
      expect(
        schema.decode('UintMessage', Uint8List.fromList(output)),
        equals(input),
      );
    }

    test('empty', () => check({}, [0]));
    test('value', () => check({'x': 12345678}, [1, 206, 194, 241, 5, 0]));
  });

  group('message int', () {
    void check(Map<String, dynamic> input, List<int> output) {
      expect(
        schema.encode('IntMessage', input),
        equals(Uint8List.fromList(output)),
      );
      expect(
        schema.decode('IntMessage', Uint8List.fromList(output)),
        equals(input),
      );
    }

    test('empty', () => check({}, [0]));
    test('value', () => check({'x': 12345678}, [1, 156, 133, 227, 11, 0]));
  });

  group('message float', () {
    void check(Map<String, dynamic> input, List<int> output) {
      expect(
        schema.encode('FloatMessage', input),
        equals(Uint8List.fromList(output)),
      );
      expect(
        schema.decode('FloatMessage', Uint8List.fromList(output)),
        equals(input),
      );
    }

    test('empty', () => check({}, [0]));
    test('value', () => check({'x': 3.1415927410125732}, [1, 128, 182, 31, 146, 0]));
  });

  group('message string', () {
    void check(Map<String, dynamic> input, List<int> output) {
      expect(
        schema.encode('StringMessage', input),
        equals(Uint8List.fromList(output)),
      );
      expect(
        schema.decode('StringMessage', Uint8List.fromList(output)),
        equals(input),
      );
    }

    test('empty', () => check({}, [0]));
    test('empty string', () => check({'x': ''}, [1, 0, 0]));
    test('emoji', () => check({'x': 'ðŸ™‰ðŸ™ˆðŸ™Š'}, [1, 240, 159, 153, 137, 240, 159, 153, 136, 240, 159, 153, 138, 0, 0]));
  });

  group('message compound', () {
    void check(Map<String, dynamic> input, List<int> output) {
      expect(
        schema.encode('CompoundMessage', input),
        equals(Uint8List.fromList(output)),
      );
      expect(
        schema.decode('CompoundMessage', Uint8List.fromList(output)),
        equals(input),
      );
    }

    test('empty', () => check({}, [0]));
    test('x only', () => check({'x': 123}, [1, 123, 0]));
    test('y only', () => check({'y': 234}, [2, 234, 1, 0]));
    test('both', () => check({'x': 123, 'y': 234}, [1, 123, 2, 234, 1, 0]));
  });

  group('message nested', () {
    void check(Map<String, dynamic> input, List<int> output) {
      expect(
        schema.encode('NestedMessage', input),
        equals(Uint8List.fromList(output)),
      );
      expect(
        schema.decode('NestedMessage', Uint8List.fromList(output)),
        equals(input),
      );
    }

    test('empty', () => check({}, [0]));
    test('a and c', () => check({'a': 123, 'c': 234}, [1, 123, 3, 234, 1, 0]));
    test('b only', () => check({'b': {'x': 5, 'y': 6}}, [2, 1, 5, 2, 6, 0, 0]));
    test('b and c', () => check({'b': {'x': 5}, 'c': 123}, [2, 1, 5, 0, 3, 123, 0]));
    test('all', () => check({'c': 123, 'b': {'x': 5, 'y': 6}, 'a': 234}, [1, 234, 1, 2, 1, 5, 2, 6, 0, 3, 123, 0]));
  });

  group('struct bool array', () {
    void check(List<bool> input, List<int> output) {
      expect(
        schema.encode('BoolArrayStruct', {'x': input}),
        equals(Uint8List.fromList(output)),
      );
      expect(
        schema.decode('BoolArrayStruct', Uint8List.fromList(output)),
        equals({'x': input}),
      );
    }

    test('empty', () => check([], [0]));
    test('values', () => check([true, false], [2, 1, 0]));
  });

  group('message bool array', () {
    void check(Map<String, dynamic> input, List<int> output) {
      expect(
        schema.encode('BoolArrayMessage', input),
        equals(Uint8List.fromList(output)),
      );
      expect(
        schema.decode('BoolArrayMessage', Uint8List.fromList(output)),
        equals(input),
      );
    }

    test('empty', () => check({}, [0]));
    test('empty array', () => check({'x': []}, [1, 0, 0]));
    test('values', () => check({'x': [true, false]}, [1, 2, 1, 0, 0]));
  });

  group('recursive message', () {
    void check(Map<String, dynamic> input, List<int> output) {
      expect(
        schema.encode('RecursiveMessage', input),
        equals(Uint8List.fromList(output)),
      );
      expect(
        schema.decode('RecursiveMessage', Uint8List.fromList(output)),
        equals(input),
      );
    }

    test('empty', () => check({}, [0]));
    test('one level', () => check({'x': {}}, [1, 0, 0]));
    test('two levels', () => check({'x': {'x': {}}}, [1, 1, 0, 0, 0]));
  });

  group('binary schema', () {
    test('round trip encoding', () {
      var compiledSchema = compileSchema(decodeBinarySchema(encodeBinarySchema(parseSchema(schemaText))));

      void check(Map<String, dynamic> message) {
        expect(
          schema.encode('NestedMessage', message),
          equals(compiledSchema.encode('NestedMessage', message)),
        );
      }

      check({'a': 1, 'c': 4});
      check({'a': 1, 'b': {}, 'c': 4});
      check({'a': 1, 'b': {'x': 2, 'y': 3}, 'c': 4});
    });
  });

  group('large schema', () {
    late String largeSchemaText;
    late CompiledSchema largeSchema;

    setUpAll(() {
      largeSchemaText = File('test/test-schema-large.kiwi').readAsStringSync();
      largeSchema = compileSchema(parseSchema(largeSchemaText));
    });

    test('struct with many fields', () {
      Map<String, dynamic> object = {};
      for (int i = 0; i < 130; i++) {
        object['f$i'] = i;
      }

      var encoded = largeSchema.encode('Struct', object);
      expect(largeSchema.decode('Struct', encoded), equals(object));
    });

    test('message with many fields', () {
      Map<String, dynamic> object = {};
      for (int i = 0; i < 130; i++) {
        object['f$i'] = i;
      }

      var encoded = largeSchema.encode('Message', object);
      expect(largeSchema.decode('Message', encoded), equals(object));
    });
  });

  group('deprecated fields', () {
    test('deprecated fields are skipped', () {
      var nonDeprecated = {
        'a': 1,
        'b': 2,
        'c': [3, 4, 5],
        'd': [6, 7, 8],
        'e': {'x': 123},
        'f': {'x': 234},
        'g': 9,
      };

      var deprecated = {
        'a': 1,
        'c': [3, 4, 5],
        'e': {'x': 123},
        'g': 9,
      };

      expect(
        schema.decode('DeprecatedMessage', schema.encode('NonDeprecatedMessage', nonDeprecated)),
        equals(deprecated),
      );
      expect(
        schema.decode('NonDeprecatedMessage', schema.encode('DeprecatedMessage', nonDeprecated)),
        equals(deprecated),
      );
    });
  });

  group('schema round trip', () {
    test('parse and print produces equivalent schema', () {
      var parsed = parseSchema(schemaText);
      var schemaText2 = prettyPrintSchema(parsed);
      var parsed2 = parseSchema(schemaText2);

      // Compare definitions (ignoring line/column)
      expect(parsed.definitions.length, equals(parsed2.definitions.length));
      for (int i = 0; i < parsed.definitions.length; i++) {
        var d1 = parsed.definitions[i];
        var d2 = parsed2.definitions[i];
        expect(d1.name, equals(d2.name));
        expect(d1.kind, equals(d2.kind));
        expect(d1.fields.length, equals(d2.fields.length));
        for (int j = 0; j < d1.fields.length; j++) {
          var f1 = d1.fields[j];
          var f2 = d2.fields[j];
          expect(f1.name, equals(f2.name));
          expect(f1.type, equals(f2.type));
          expect(f1.isArray, equals(f2.isArray));
          expect(f1.isDeprecated, equals(f2.isDeprecated));
          expect(f1.value, equals(f2.value));
        }
      }
    });
  });

  group('enum', () {
    test('encode and decode enum values', () {
      expect(
        schema.encode('EnumStruct', {'x': 'A', 'y': ['A', 'B']}),
        equals(Uint8List.fromList([100, 2, 100, 200, 1])),
      );
      expect(
        schema.decode('EnumStruct', Uint8List.fromList([100, 2, 100, 200, 1])),
        equals({'x': 'A', 'y': ['A', 'B']}),
      );
    });
  });
}

import 'dart:html';
import 'dart:convert';
import 'dart:typed_data';
import 'package:kiwi_schema/kiwi.dart';

TextAreaElement? jsonElement;
TextAreaElement? binaryElement;
TextAreaElement? schemaElement;
TextAreaElement? logElement;

void main() {
  jsonElement = querySelector('#json') as TextAreaElement?;
  binaryElement = querySelector('#binary') as TextAreaElement?;
  schemaElement = querySelector('#schema') as TextAreaElement?;
  logElement = querySelector('#log') as TextAreaElement?;

  jsonElement?.onFocus.listen((_) => update());
  jsonElement?.onInput.listen((_) => update());
  binaryElement?.onFocus.listen((_) => update());
  binaryElement?.onInput.listen((_) => update());
  schemaElement?.onFocus.listen((_) => update());
  schemaElement?.onInput.listen((_) => update());

  update();
}

String toHex(Uint8List value) {
  return value.map((x) => x.toRadixString(16).padLeft(2, '0')).join(' ');
}

Uint8List fromHex(String value) {
  var parts = value.trim().split(RegExp(r'[\s,]+'));
  if (parts.length == 1 && parts[0].isEmpty) {
    return Uint8List(0);
  }
  return Uint8List.fromList(
    parts.map((x) => int.parse(x, radix: 16)).toList(),
  );
}

String? findLastMessageOrStruct(String schemaText) {
  final regex = RegExp(r'\b(?:message|struct)\s+(\w+)\b');
  String? lastName;
  for (var match in regex.allMatches(schemaText)) {
    lastName = match.group(1);
  }
  return lastName;
}

void update() {
  try {
    var compiled = compileSchema(schemaElement?.value ?? '');
    var name = findLastMessageOrStruct(schemaElement?.value ?? '');

    if (name == null) {
      throw Exception('No message or struct found');
    }

    if (document.activeElement == jsonElement) {
      var jsonData = json.decode(jsonElement?.value ?? '{}') as Map<String, dynamic>;
      var encoded = compiled.encode(name, jsonData);
      binaryElement?.value = '${toHex(encoded)}\n';
    } else if (document.activeElement == binaryElement) {
      var decoded = compiled.decode(name, fromHex(binaryElement?.value ?? ''));
      jsonElement?.value = '${const JsonEncoder.withIndent('  ').convert(decoded)}\n';
    }

    logElement?.value = 'Success';
  } catch (e, stack) {
    logElement?.value = '$e\n$stack';
  }
}

// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:kiwi_demo/main.dart';

void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(const MyApp());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}

import 'dart:convert';
import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:kiwi_schema/kiwi.dart';

void main() {
  runApp(const KiwiDemoApp());
}

class KiwiDemoApp extends StatelessWidget {
  const KiwiDemoApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Kiwi File Format Demo',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
        useMaterial3: true,
      ),
      home: const KiwiDemoPage(),
    );
  }
}

class KiwiDemoPage extends StatefulWidget {
  const KiwiDemoPage({super.key});

  @override
  State<KiwiDemoPage> createState() => _KiwiDemoPageState();
}

class _KiwiDemoPageState extends State<KiwiDemoPage> {
  final TextEditingController _jsonController = TextEditingController();
  final TextEditingController _binaryController = TextEditingController();
  final TextEditingController _schemaController = TextEditingController();
  final TextEditingController _logController = TextEditingController();

  final FocusNode _jsonFocus = FocusNode();
  final FocusNode _binaryFocus = FocusNode();
  final FocusNode _schemaFocus = FocusNode();

  @override
  void initState() {
    super.initState();

    _jsonController.text = '''{
  "clientID": 100,
  "type": "POINTED",
  "colors": [
    {
      "red": 255,
      "green": 127,
      "blue": 0,
      "alpha": 255
    }
  ]
}''';

    _schemaController.text = '''enum Type {
  FLAT = 0;
  ROUND = 1;
  POINTED = 2;
}

struct Color {
  byte red;
  byte green;
  byte blue;
  byte alpha;
}

message Example {
  uint clientID = 1;
  Type type = 2;
  Color[] colors = 3;
}''';

    _jsonFocus.addListener(_onFocusChange);
    _binaryFocus.addListener(_onFocusChange);
    _schemaFocus.addListener(_onFocusChange);

    // Initial update
    WidgetsBinding.instance.addPostFrameCallback((_) => _update());
  }

  @override
  void dispose() {
    _jsonController.dispose();
    _binaryController.dispose();
    _schemaController.dispose();
    _logController.dispose();
    _jsonFocus.dispose();
    _binaryFocus.dispose();
    _schemaFocus.dispose();
    super.dispose();
  }

  void _onFocusChange() {
    _update();
  }

  String _toHex(Uint8List value) {
    return value.map((x) => x.toRadixString(16).padLeft(2, '0')).join(' ');
  }

  Uint8List _fromHex(String value) {
    var parts = value.trim().split(RegExp(r'[\s,]+'));
    if (parts.length == 1 && parts[0].isEmpty) {
      return Uint8List(0);
    }
    return Uint8List.fromList(
      parts.map((x) => int.parse(x, radix: 16)).toList(),
    );
  }

  String? _findLastMessageOrStruct(String schemaText) {
    // Find the last message or struct name
    final regex = RegExp(r'\b(?:message|struct)\s+(\w+)\b');
    String? lastName;
    for (var match in regex.allMatches(schemaText)) {
      lastName = match.group(1);
    }
    return lastName;
  }

  void _update() {
    try {
      var compiled = compileSchema(_schemaController.text);
      var name = _findLastMessageOrStruct(_schemaController.text);

      if (name == null) {
        throw Exception('No message or struct found');
      }

      if (_jsonFocus.hasFocus) {
        var jsonData = json.decode(_jsonController.text) as Map<String, dynamic>;
        var encoded = compiled.encode(name, jsonData);
        _binaryController.text = '${_toHex(encoded)}\n';
      } else if (_binaryFocus.hasFocus) {
        var decoded = compiled.decode(name, _fromHex(_binaryController.text));
        _jsonController.text = '${const JsonEncoder.withIndent('  ').convert(decoded)}\n';
      }

      _logController.text = 'Success';
    } catch (e, stack) {
      _logController.text = '$e\n$stack';
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Kiwi File Format Demo'),
        backgroundColor: Theme.of(context).colorScheme.inversePrimary,
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'See https://github.com/evanw/kiwi for more information.',
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            const SizedBox(height: 24),
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(
                  child: _buildSection(
                    'JSON',
                    _jsonController,
                    _jsonFocus,
                    autofocus: true,
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: _buildSection(
                    'Binary',
                    _binaryController,
                    _binaryFocus,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 24),
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(
                  child: _buildSection(
                    'Schema',
                    _schemaController,
                    _schemaFocus,
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: _buildSection(
                    'Log',
                    _logController,
                    null,
                    readOnly: true,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSection(
    String title,
    TextEditingController controller,
    FocusNode? focusNode, {
    bool readOnly = false,
    bool autofocus = false,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: Theme.of(context).textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
        ),
        const SizedBox(height: 8),
        SizedBox(
          height: 300,
          child: TextField(
            controller: controller,
            focusNode: focusNode,
            readOnly: readOnly,
            autofocus: autofocus,
            maxLines: null,
            expands: true,
            textAlignVertical: TextAlignVertical.top,
            style: const TextStyle(
              fontFamily: 'monospace',
              fontSize: 12,
            ),
            decoration: InputDecoration(
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(8),
              ),
              contentPadding: const EdgeInsets.all(12),
            ),
            onChanged: (_) => _update(),
          ),
        ),
      ],
    );
  }
}

/// Figma File Browser and Viewer
///
/// Lists .fig files from a specified directory and allows viewing them.

import 'dart:io';
import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:kiwi_schema/kiwi.dart';
import 'package:kiwi_schema/flutter_renderer.dart';

// ============================================================================
// DEBUG CONFIGURATION - Toggle these flags to enable/disable debug features
// ============================================================================
class DebugConfig {
  /// Master switch - set to false to disable ALL debug features
  static const bool enabled = true;

  /// Auto-open first .fig file on app start
  static const bool autoOpenFirstFile = enabled && true;

  /// Initial page index to show (null = first page)
  /// 0=System Experiences, 1=Internal Only (1411), 7=App Logos, 12=Welcome
  static const int? initialPageIndex = enabled ? 12 : null; // 12 = Welcome (has Components Index)

  /// Enable verbose image loading logs
  static const bool logImageLoading = enabled && false; // Disable to reduce spam

  /// Enable page list logging
  static const bool logPageList = enabled && false; // Disable to reduce spam
}

/// Decompress ZSTD data using system zstd command
Future<Uint8List> decompressZstd(Uint8List data) async {
  // Write to temp file
  final tempDir = Directory.systemTemp;
  final inputFile = File('${tempDir.path}/zstd_input_${DateTime.now().millisecondsSinceEpoch}.zst');
  final outputFile = File('${tempDir.path}/zstd_output_${DateTime.now().millisecondsSinceEpoch}.bin');

  try {
    await inputFile.writeAsBytes(data);

    // Run zstd -d
    final result = await Process.run('zstd', ['-d', inputFile.path, '-o', outputFile.path]);

    if (result.exitCode != 0) {
      throw Exception('ZSTD decompression failed: ${result.stderr}');
    }

    final decompressed = await outputFile.readAsBytes();
    return decompressed;
  } finally {
    // Cleanup
    if (await inputFile.exists()) await inputFile.delete();
    if (await outputFile.exists()) await outputFile.delete();
  }
}

void main() {
  runApp(const FigmaBrowserApp());
}

class FigmaBrowserApp extends StatelessWidget {
  const FigmaBrowserApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Figma Browser',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: Colors.indigo,
          brightness: Brightness.light,
        ),
        useMaterial3: true,
      ),
      darkTheme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: Colors.indigo,
          brightness: Brightness.dark,
        ),
        useMaterial3: true,
      ),
      home: const FigmaFileBrowser(),
    );
  }
}

class FigmaFileBrowser extends StatefulWidget {
  const FigmaFileBrowser({super.key});

  @override
  State<FigmaFileBrowser> createState() => _FigmaFileBrowserState();
}

class _FigmaFileBrowserState extends State<FigmaFileBrowser> {
  List<FileSystemEntity> _figFiles = [];
  bool _isLoading = true;
  String? _error;

  // Uses DebugConfig for auto-open behavior

  // Default paths to search for .fig files
  static const _searchPaths = [
    '/Users/johndpope/Downloads/Apple iOS UI Kit',
    '/Users/johndpope/Downloads',
  ];

  @override
  void initState() {
    super.initState();
    _loadFigFiles();
  }

  Future<void> _loadFigFiles() async {
    setState(() {
      _isLoading = true;
      _error = null;
    });

    try {
      final files = <FileSystemEntity>[];

      for (final path in _searchPaths) {
        final dir = Directory(path);
        if (await dir.exists()) {
          await for (final entity in dir.list(recursive: true)) {
            if (entity is File && entity.path.endsWith('.fig')) {
              files.add(entity);
            }
          }
        }
      }

      // Sort by name
      files.sort((a, b) => a.path.compareTo(b.path));

      setState(() {
        _figFiles = files;
        _isLoading = false;
      });

      // Auto-open first file for debugging
      if (DebugConfig.autoOpenFirstFile && files.isNotEmpty && mounted) {
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (mounted) _openFigFile(files.first as File);
        });
      }
    } catch (e) {
      setState(() {
        _error = e.toString();
        _isLoading = false;
      });
    }
  }

  String _getFileName(FileSystemEntity entity) {
    return entity.path.split('/').last;
  }

  String _getRelativePath(FileSystemEntity entity) {
    for (final searchPath in _searchPaths) {
      if (entity.path.startsWith(searchPath)) {
        return entity.path.substring(searchPath.length + 1);
      }
    }
    return entity.path;
  }

  Future<void> _openFigFile(File file) async {
    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (context) => FigmaViewerPage(file: file),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Figma Files'),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: _loadFigFiles,
          ),
        ],
      ),
      body: _buildBody(),
    );
  }

  Widget _buildBody() {
    if (_isLoading) {
      return const Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            CircularProgressIndicator(),
            SizedBox(height: 16),
            Text('Scanning for .fig files...'),
          ],
        ),
      );
    }

    if (_error != null) {
      return Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.error_outline, size: 48, color: Colors.red),
            const SizedBox(height: 16),
            Text('Error: $_error'),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: _loadFigFiles,
              child: const Text('Retry'),
            ),
          ],
        ),
      );
    }

    if (_figFiles.isEmpty) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(32),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Icon(Icons.folder_open, size: 64, color: Colors.grey),
              const SizedBox(height: 16),
              const Text(
                'No .fig files found',
                style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              Text(
                'Searched in:\n${_searchPaths.join('\n')}',
                textAlign: TextAlign.center,
                style: const TextStyle(color: Colors.grey),
              ),
            ],
          ),
        ),
      );
    }

    return ListView.builder(
      itemCount: _figFiles.length,
      itemBuilder: (context, index) {
        final file = _figFiles[index] as File;
        final fileName = _getFileName(file);
        final relativePath = _getRelativePath(file);

        return ListTile(
          leading: Container(
            width: 48,
            height: 48,
            decoration: BoxDecoration(
              color: Theme.of(context).colorScheme.primaryContainer,
              borderRadius: BorderRadius.circular(8),
            ),
            child: Icon(
              Icons.design_services,
              color: Theme.of(context).colorScheme.primary,
            ),
          ),
          title: Text(fileName),
          subtitle: Text(
            relativePath != fileName ? relativePath : 'Figma Design File',
            style: const TextStyle(fontSize: 12),
          ),
          trailing: const Icon(Icons.chevron_right),
          onTap: () => _openFigFile(file),
        );
      },
    );
  }
}

class FigmaViewerPage extends StatefulWidget {
  final File file;

  const FigmaViewerPage({super.key, required this.file});

  @override
  State<FigmaViewerPage> createState() => _FigmaViewerPageState();
}

class _FigmaViewerPageState extends State<FigmaViewerPage> {
  FigmaDocument? _document;
  String? _error;
  bool _isLoading = true;
  String _statusMessage = 'Loading...';
  double _progress = 0;

  @override
  void initState() {
    super.initState();
    // Delay loading to allow page transition animation to complete
    Future.delayed(const Duration(milliseconds: 350), () {
      if (mounted) _loadFile();
    });
  }

  Future<void> _loadFile() async {
    setState(() {
      _isLoading = true;
      _statusMessage = 'Reading file...';
      _progress = 0.1;
    });

    // Allow UI to update before heavy work
    await Future.delayed(const Duration(milliseconds: 50));

    try {
      final data = await widget.file.readAsBytes();

      setState(() {
        _statusMessage = 'Parsing file structure...';
        _progress = 0.3;
      });

      // Parse the file structure
      final figFile = parseFigFileStructure(data);

      setState(() {
        _statusMessage = 'Decompressing schema...';
        _progress = 0.5;
      });

      // Decompress schema - try multiple approaches
      Uint8List schemaBytes;
      final schemaData = figFile.schemaChunk.data;

      // Check for ZSTD in schema chunk first
      if (schemaData.length >= 4 &&
          schemaData[0] == 0x28 && schemaData[1] == 0xB5 &&
          schemaData[2] == 0x2F && schemaData[3] == 0xFD) {
        schemaBytes = await decompressZstd(schemaData);
      } else if (figFile.schemaChunk.isZlib) {
        schemaBytes = Uint8List.fromList(
          zlib.decoder.convert(schemaData.toList()),
        );
      } else if (figFile.schemaChunk.isDeflate) {
        // Try raw deflate using RawZLibFilter
        try {
          final filter = RawZLibFilter.inflateFilter(raw: true);
          filter.process(schemaData, 0, schemaData.length);
          final chunks = <List<int>>[];
          List<int>? chunk;
          while ((chunk = filter.processed()) != null) {
            chunks.add(chunk!);
          }
          schemaBytes = Uint8List.fromList(chunks.expand((e) => e).toList());
        } catch (e) {
          // If deflate fails, try as raw binary schema
          schemaBytes = schemaData;
        }
      } else {
        schemaBytes = schemaData;
      }

      setState(() {
        _statusMessage = 'Parsing schema...';
        _progress = 0.6;
      });

      final schema = decodeBinarySchema(schemaBytes);
      final compiled = compileSchema(schema);

      setState(() {
        _statusMessage = 'Decompressing data...';
        _progress = 0.7;
      });

      // Check compression type for data chunk
      Uint8List messageBytes;
      if (figFile.dataChunk.isZstd) {
        setState(() {
          _statusMessage = 'Decompressing ZSTD data...';
          _progress = 0.75;
        });

        // Use system zstd command for decompression
        messageBytes = await decompressZstd(figFile.dataChunk.data);
      } else if (figFile.dataChunk.isDeflate) {
        messageBytes = Uint8List.fromList(
          zlib.decoder.convert(figFile.dataChunk.data.toList()),
        );
      } else if (figFile.dataChunk.isZlib) {
        messageBytes = Uint8List.fromList(
          zlib.decoder.convert(figFile.dataChunk.data.toList()),
        );
      } else {
        messageBytes = figFile.dataChunk.data;
      }

      setState(() {
        _statusMessage = 'Decoding message...';
        _progress = 0.9;
      });

      final message = compiled.decode('Message', messageBytes);
      final document = FigmaDocument.fromMessage(message);

      // Set images directory (same folder as .fig file)
      final figDir = widget.file.parent.path;
      final imagesDir = '$figDir/images';
      if (await Directory(imagesDir).exists()) {
        document.imagesDirectory = imagesDir;
        if (DebugConfig.logImageLoading) {
          print('DEBUG: Images directory: $imagesDir');
        }
        // Audit images to find missing ones
        document.auditImages();
      }

      setState(() {
        _document = document;
        _isLoading = false;
        _statusMessage = 'Loaded ${document.nodeCount} nodes';
      });
    } catch (e) {
      setState(() {
        _error = e.toString();
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final fileName = widget.file.path.split('/').last;

    if (_error != null) {
      return Scaffold(
        appBar: AppBar(title: Text(fileName)),
        body: Center(
          child: Padding(
            padding: const EdgeInsets.all(32),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const Icon(Icons.error_outline, size: 48, color: Colors.red),
                const SizedBox(height: 16),
                Text(
                  'Error loading file',
                  style: Theme.of(context).textTheme.titleLarge,
                ),
                const SizedBox(height: 8),
                Text(
                  _error!,
                  textAlign: TextAlign.center,
                  style: const TextStyle(color: Colors.grey),
                ),
                const SizedBox(height: 24),
                ElevatedButton(
                  onPressed: _loadFile,
                  child: const Text('Retry'),
                ),
              ],
            ),
          ),
        ),
      );
    }

    if (_isLoading) {
      return Scaffold(
        appBar: AppBar(title: Text(fileName)),
        body: Center(
          child: Padding(
            padding: const EdgeInsets.all(32),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                SizedBox(
                  width: 200,
                  child: LinearProgressIndicator(value: _progress),
                ),
                const SizedBox(height: 24),
                Text(
                  _statusMessage,
                  style: Theme.of(context).textTheme.titleMedium,
                ),
                const SizedBox(height: 8),
                Text(
                  '${(_progress * 100).toInt()}%',
                  style: const TextStyle(color: Colors.grey),
                ),
              ],
            ),
          ),
        ),
      );
    }

    if (_document == null) {
      return Scaffold(
        appBar: AppBar(title: Text(fileName)),
        body: const Center(
          child: Text('No document loaded'),
        ),
      );
    }

    return Scaffold(
      appBar: AppBar(
        title: Text(fileName),
        actions: [
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16),
            child: Center(
              child: Text(
                '${_document!.nodeCount} nodes',
                style: const TextStyle(fontSize: 12),
              ),
            ),
          ),
        ],
      ),
      body: FigmaCanvasView(
        document: _document!,
        initialPageIndex: DebugConfig.initialPageIndex ?? 0,
        showPageSelector: true,
        showDebugInfo: DebugConfig.enabled,
      ),
    );
  }
}

/// Figma Viewer Example
///
/// This example demonstrates how to load and render a Figma .fig file
/// using the kiwi_schema library.
///
/// Note: This example requires external decompression libraries for
/// ZSTD and DEFLATE support. On desktop, you can use dart:io's zlib.
/// For ZSTD, you'll need a native library binding.

import 'dart:io';
import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:kiwi_schema/kiwi.dart';
import 'package:kiwi_schema/flutter_renderer.dart';

void main() {
  runApp(const FigmaViewerApp());
}

class FigmaViewerApp extends StatelessWidget {
  const FigmaViewerApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Figma Viewer',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.indigo),
        useMaterial3: true,
      ),
      home: const FigmaViewerPage(),
    );
  }
}

class FigmaViewerPage extends StatefulWidget {
  const FigmaViewerPage({super.key});

  @override
  State<FigmaViewerPage> createState() => _FigmaViewerPageState();
}

class _FigmaViewerPageState extends State<FigmaViewerPage> {
  FigmaDocument? _document;
  String? _error;
  bool _isLoading = false;
  String _statusMessage = '';

  @override
  void initState() {
    super.initState();
    _loadExampleFile();
  }

  Future<void> _loadExampleFile() async {
    // Try to load the Apple iOS UI Kit from the fixtures
    final paths = [
      '${Directory.current.path}/../Apple_iOS_UI_Kit/canvas.fig',
      '${Directory.current.path}/../../Apple_iOS_UI_Kit/canvas.fig',
      'test/fixtures/figma_message.bin', // Pre-decompressed message
    ];

    for (final path in paths) {
      final file = File(path);
      if (await file.exists()) {
        if (path.endsWith('.fig')) {
          // For .fig files, we need decompression
          setState(() {
            _statusMessage = 'Found .fig file but ZSTD decompression not available.\n'
                'Use the pre-decompressed fixtures or add ZSTD support.';
          });
        } else if (path.endsWith('.bin')) {
          await _loadPreDecompressedMessage(file);
        }
        return;
      }
    }

    setState(() {
      _statusMessage = 'No Figma file found. Place canvas.fig in Apple_iOS_UI_Kit/ directory.';
    });
  }

  Future<void> _loadPreDecompressedMessage(File messageFile) async {
    setState(() {
      _isLoading = true;
      _statusMessage = 'Loading pre-decompressed message...';
    });

    try {
      // Load schema
      final schemaFile = File('${Directory.current.path}/test/fixtures/figma_schema.bin');
      if (!schemaFile.existsSync()) {
        throw Exception('Schema file not found');
      }

      final schemaBytes = await schemaFile.readAsBytes();
      final messageBytes = await messageFile.readAsBytes();

      // Decode
      final schema = decodeBinarySchema(schemaBytes);
      final compiled = compileSchema(schema);
      final message = compiled.decode('Message', messageBytes);

      // Create document
      final document = FigmaDocument.fromMessage(message);

      setState(() {
        _document = document;
        _isLoading = false;
        _statusMessage = 'Loaded ${document.nodeCount} nodes';
      });
    } catch (e) {
      setState(() {
        _error = e.toString();
        _isLoading = false;
      });
    }
  }

  Future<void> _loadFigFile(File file) async {
    setState(() {
      _isLoading = true;
      _statusMessage = 'Parsing file structure...';
    });

    try {
      final data = await file.readAsBytes();

      // Parse the file structure first
      final figFile = parseFigFileStructure(data);

      setState(() {
        _statusMessage = 'File: ${figFile.header.prelude}\n'
            'Schema: ${figFile.schemaChunk.data.length} bytes (${figFile.schemaChunk.compression.name})\n'
            'Data: ${figFile.dataChunk.data.length} bytes (${figFile.dataChunk.compression.name})';
      });

      // For full parsing, we need decompression
      // The schema uses raw DEFLATE, data uses ZSTD
      if (figFile.schemaChunk.isDeflate && figFile.dataChunk.isZstd) {
        setState(() {
          _statusMessage += '\n\nNote: Full parsing requires ZSTD and DEFLATE decompression.\n'
              'On desktop, DEFLATE is available via dart:io zlib.\n'
              'For ZSTD, you need a native library like zstd_dart.';
        });
      }
    } catch (e) {
      setState(() {
        _error = e.toString();
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_error != null) {
      return Scaffold(
        appBar: AppBar(title: const Text('Figma Viewer')),
        body: Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Icon(Icons.error_outline, size: 48, color: Colors.red),
              const SizedBox(height: 16),
              Text('Error: $_error'),
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: () {
                  setState(() {
                    _error = null;
                  });
                  _loadExampleFile();
                },
                child: const Text('Retry'),
              ),
            ],
          ),
        ),
      );
    }

    if (_isLoading) {
      return Scaffold(
        appBar: AppBar(title: const Text('Figma Viewer')),
        body: Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const CircularProgressIndicator(),
              const SizedBox(height: 16),
              Text(_statusMessage),
            ],
          ),
        ),
      );
    }

    if (_document == null) {
      return Scaffold(
        appBar: AppBar(title: const Text('Figma Viewer')),
        body: Center(
          child: Padding(
            padding: const EdgeInsets.all(32),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const Icon(Icons.insert_drive_file, size: 64, color: Colors.grey),
                const SizedBox(height: 16),
                const Text(
                  'Figma Viewer',
                  style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
                ),
                const SizedBox(height: 8),
                Text(
                  _statusMessage.isEmpty
                      ? 'No document loaded'
                      : _statusMessage,
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 24),
                const Text(
                  'To use this viewer:\n\n'
                  '1. Export a Figma file (.fig)\n'
                  '2. Place it in the Apple_iOS_UI_Kit directory\n'
                  '3. Add ZSTD decompression support\n\n'
                  'Or use the pre-decompressed test fixtures.',
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          ),
        ),
      );
    }

    return FigmaCanvasView(
      document: _document!,
      showPageSelector: true,
      showDebugInfo: true,
    );
  }
}

/// Example of manually loading a Figma file with custom decompression
///
/// This shows how you would integrate with a ZSTD library:
/// ```dart
/// import 'package:zstd/zstd.dart' as zstd;
///
/// final parsed = parseFigFile(
///   fileData,
///   zstdDecompress: (data) => Uint8List.fromList(zstd.decode(data)),
///   deflateDecompress: (data) => Uint8List.fromList(
///     zlib.ZLibDecoder(raw: true).convert(data)),
/// );
///
/// final document = FigmaDocument.fromMessage(parsed.message);
/// ```
class FigmaFileLoader {
  /// Load a Figma file with decompression support
  ///
  /// Example with dart:io zlib for DEFLATE:
  /// ```dart
  /// import 'dart:io';
  ///
  /// final loader = FigmaFileLoader(
  ///   deflateDecompress: (data) {
  ///     return Uint8List.fromList(
  ///       zlib.ZLibDecoder(raw: true).convert(data.toList())
  ///     );
  ///   },
  /// );
  /// ```
  final Uint8List Function(Uint8List)? zstdDecompress;
  final Uint8List Function(Uint8List)? deflateDecompress;
  final Uint8List Function(Uint8List)? zlibDecompress;

  FigmaFileLoader({
    this.zstdDecompress,
    this.deflateDecompress,
    this.zlibDecompress,
  });

  FigmaDocument load(Uint8List data) {
    final parsed = parseFigFile(
      data,
      zstdDecompress: zstdDecompress,
      deflateDecompress: deflateDecompress,
      zlibDecompress: zlibDecompress,
    );

    return FigmaDocument.fromMessage(parsed.message);
  }

  FigFile parseStructureOnly(Uint8List data) {
    return parseFigFileStructure(data);
  }
}

/// Kiwi schema-based binary serialization format for Dart/Flutter.
///
/// Kiwi is designed for efficiently encoding trees of data with:
/// - Efficient compact encoding using variable-length encoding
/// - Support for optional fields with detectable presence
/// - Linear serialization for cache efficiency
/// - Backwards & forwards compatibility
library kiwi;

export 'src/byte_buffer.dart';
export 'src/schema.dart';
export 'src/parser.dart';
export 'src/binary.dart';
export 'src/compiler.dart';
export 'src/printer.dart';
export 'src/figma.dart';
export 'src/fig_file.dart';

/// Flutter renderer for Figma nodes
///
/// This library provides Flutter widgets to render Figma documents.
/// Note: This library requires Flutter and is separate from the core kiwi library.
///
/// Example usage:
/// ```dart
/// import 'package:kiwi_schema/kiwi.dart';
/// import 'package:kiwi_schema/flutter_renderer.dart';
///
/// // Parse a Figma file
/// final parsed = parseFigFile(
///   fileData,
///   zstdDecompress: (data) => zstd.decode(data),
///   deflateDecompress: (data) => zlib.ZLibDecoder(raw: true).convert(data),
/// );
///
/// // Create a document from the parsed message
/// final document = FigmaDocument.fromMessage(parsed.message);
///
/// // Use in a widget
/// FigmaCanvasView(document: document)
/// ```
library flutter_renderer;

export 'src/flutter/node_renderer.dart';
export 'src/flutter/figma_canvas.dart';

import 'dart:typed_data';
import 'byte_buffer.dart';
import 'schema.dart';

// Standard kiwi types plus extended types used by Figma
const List<String?> _types = [
  'bool',    // 0
  'byte',    // 1
  'int',     // 2
  'uint',    // 3
  'float',   // 4
  'string',  // 5
  'int64',   // 6 - Figma extension
  'uint64',  // 7 - Figma extension
];
const List<DefinitionKind> _kinds = [
  DefinitionKind.ENUM,
  DefinitionKind.STRUCT,
  DefinitionKind.MESSAGE
];

/// Decodes a binary-encoded schema into a Schema object.
Schema decodeBinarySchema(dynamic buffer) {
  ByteBuffer bb;
  if (buffer is ByteBuffer) {
    bb = buffer;
  } else if (buffer is Uint8List) {
    bb = ByteBuffer(buffer);
  } else {
    throw ArgumentError('Buffer must be a ByteBuffer or Uint8List');
  }

  int definitionCount = bb.readVarUint();
  List<Definition> definitions = [];

  // Read in the schema
  for (int i = 0; i < definitionCount; i++) {
    String definitionName = bb.readString();
    int kindIndex = bb.readByte();
    int fieldCount = bb.readVarUint();
    List<Field> fields = [];

    for (int j = 0; j < fieldCount; j++) {
      String fieldName = bb.readString();
      int type = bb.readVarInt();
      bool isArray = (bb.readByte() & 1) != 0;
      int value = bb.readVarUint();

      fields.add(Field(
        name: fieldName,
        line: 0,
        column: 0,
        // Store type as string representation of the index temporarily
        type: _kinds[kindIndex] == DefinitionKind.ENUM ? null : type.toString(),
        isArray: isArray,
        isDeprecated: false,
        value: value,
      ));
    }

    definitions.add(Definition(
      name: definitionName,
      line: 0,
      column: 0,
      kind: _kinds[kindIndex],
      fields: fields,
    ));
  }

  // Bind type names afterwards
  for (int i = 0; i < definitionCount; i++) {
    var fields = definitions[i].fields;
    for (int j = 0; j < fields.length; j++) {
      var field = fields[j];
      if (field.type != null) {
        int type = int.parse(field.type!);

        if (type < 0) {
          int typeIndex = ~type;
          if (typeIndex >= _types.length) {
            throw Exception('Invalid type $type');
          }
          field.type = _types[typeIndex];
        } else {
          if (type >= definitions.length) {
            throw Exception('Invalid type $type');
          }
          field.type = definitions[type].name;
        }
      }
    }
  }

  return Schema(
    package: null,
    definitions: definitions,
  );
}

/// Encodes a schema into binary format.
Uint8List encodeBinarySchema(Schema schema) {
  ByteBuffer bb = ByteBuffer();
  var definitions = schema.definitions;
  Map<String, int> definitionIndex = {};

  bb.writeVarUint(definitions.length);

  for (int i = 0; i < definitions.length; i++) {
    definitionIndex[definitions[i].name] = i;
  }

  for (int i = 0; i < definitions.length; i++) {
    var definition = definitions[i];

    bb.writeString(definition.name);
    bb.writeByte(_kinds.indexOf(definition.kind));
    bb.writeVarUint(definition.fields.length);

    for (int j = 0; j < definition.fields.length; j++) {
      var field = definition.fields[j];
      int typeIndex = field.type != null ? _types.indexOf(field.type) : -1;

      bb.writeString(field.name);
      // For enums, field.type is null, write 0 as placeholder
      if (field.type == null) {
        bb.writeVarInt(0);
      } else {
        bb.writeVarInt(typeIndex == -1 ? definitionIndex[field.type!]! : ~typeIndex);
      }
      bb.writeByte(field.isArray ? 1 : 0);
      bb.writeVarUint(field.value);
    }
  }

  return bb.toUint8Array();
}

import 'schema.dart';

/// Native types supported by Kiwi.
const List<String> nativeTypes = [
  'bool',
  'byte',
  'float',
  'int',
  'string',
  'uint',
];

/// Reserved names that cannot be used as type names.
const List<String> reservedNames = [
  'ByteBuffer',
  'package',
];

/// Represents a token from the lexer.
class _Token {
  final String text;
  final int line;
  final int column;

  _Token(this.text, this.line, this.column);
}

/// Throws a parsing error with location information.
Never _error(String message, int line, int column) {
  throw FormatException('$message at line $line, column $column');
}

/// Quotes a string for error messages.
String _quote(String text) {
  return '"$text"';
}

/// Tokenizes the schema text into a list of tokens.
List<_Token> _tokenize(String text) {
  final regex = RegExp(
      r'((?:-|\b)\d+\b|[=;{}]|\[\]|\[deprecated\]|\b[A-Za-z_][A-Za-z0-9_]*\b|//.*|\s+)');
  final whitespace = RegExp(r'^//.*|\s+$');

  List<_Token> tokens = [];
  int column = 0;
  int line = 0;

  // Split by the regex, keeping matches
  List<String> parts = [];
  int lastEnd = 0;
  for (var match in regex.allMatches(text)) {
    if (match.start > lastEnd) {
      parts.add(text.substring(lastEnd, match.start));
      parts.add(match.group(0)!);
    } else {
      if (parts.isEmpty || parts.length % 2 == 0) {
        parts.add(text.substring(lastEnd, match.start));
      }
      parts.add(match.group(0)!);
    }
    lastEnd = match.end;
  }
  if (lastEnd < text.length) {
    parts.add(text.substring(lastEnd));
  }

  // Rebuild parts array similar to JS split with capturing group
  parts = [];
  lastEnd = 0;
  for (var match in regex.allMatches(text)) {
    parts.add(text.substring(lastEnd, match.start));
    parts.add(match.group(0)!);
    lastEnd = match.end;
  }
  parts.add(text.substring(lastEnd));

  for (int i = 0; i < parts.length; i++) {
    String part = parts[i];

    // Keep non-whitespace tokens (odd indices are regex matches)
    if (i % 2 == 1) {
      if (!whitespace.hasMatch(part)) {
        tokens.add(_Token(part, line + 1, column + 1));
      }
    }
    // Detect syntax errors (even indices should be empty)
    else if (part.isNotEmpty) {
      _error('Syntax error ${_quote(part)}', line + 1, column + 1);
    }

    // Keep track of line and column counts
    List<String> lines = part.split('\n');
    if (lines.length > 1) column = 0;
    line += lines.length - 1;
    column += lines.last.length;
  }

  // End-of-file token
  tokens.add(_Token('', line, column));

  return tokens;
}

/// Parses a list of tokens into a Schema.
Schema _parse(List<_Token> tokens) {
  int index = 0;

  _Token current() => tokens[index];

  bool eat(RegExp test) {
    if (test.hasMatch(current().text)) {
      index++;
      return true;
    }
    return false;
  }

  void expect(RegExp test, String expected) {
    if (!eat(test)) {
      var token = current();
      _error('Expected $expected but found ${_quote(token.text)}', token.line,
          token.column);
    }
  }

  Never unexpectedToken() {
    var token = current();
    _error('Unexpected token ${_quote(token.text)}', token.line, token.column);
  }

  // Regex patterns
  final identifier = RegExp(r'^[A-Za-z_][A-Za-z0-9_]*$');
  final endOfFile = RegExp(r'^$');
  final semicolon = RegExp(r'^;$');
  final integer = RegExp(r'^-?\d+$');
  final leftBrace = RegExp(r'^\{$');
  final rightBrace = RegExp(r'^\}$');
  final arrayToken = RegExp(r'^\[\]$');
  final enumKeyword = RegExp(r'^enum$');
  final structKeyword = RegExp(r'^struct$');
  final messageKeyword = RegExp(r'^message$');
  final packageKeyword = RegExp(r'^package$');
  final deprecatedToken = RegExp(r'^\[deprecated\]$');
  final equals = RegExp(r'^=$');

  List<Definition> definitions = [];
  String? packageText;

  if (eat(packageKeyword)) {
    packageText = current().text;
    expect(identifier, 'identifier');
    expect(semicolon, '";"');
  }

  while (index < tokens.length && !eat(endOfFile)) {
    List<Field> fields = [];
    DefinitionKind kind;

    if (eat(enumKeyword)) {
      kind = DefinitionKind.ENUM;
    } else if (eat(structKeyword)) {
      kind = DefinitionKind.STRUCT;
    } else if (eat(messageKeyword)) {
      kind = DefinitionKind.MESSAGE;
    } else {
      unexpectedToken();
    }

    // All definitions start off the same
    var name = current();
    expect(identifier, 'identifier');
    expect(leftBrace, '"{"');

    // Parse fields
    while (!eat(rightBrace)) {
      String? type;
      bool isArray = false;
      bool isDeprecated = false;

      // Enums don't have types
      if (kind != DefinitionKind.ENUM) {
        type = current().text;
        expect(identifier, 'identifier');
        isArray = eat(arrayToken);
      }

      var field = current();
      expect(identifier, 'identifier');

      // Structs don't have explicit values
      _Token? value;
      if (kind != DefinitionKind.STRUCT) {
        expect(equals, '"="');
        value = current();
        expect(integer, 'integer');

        int parsed = int.parse(value.text);
        if (parsed.toString() != value.text) {
          _error('Invalid integer ${_quote(value.text)}', value.line,
              value.column);
        }
      }

      var deprecated = current();
      if (eat(deprecatedToken)) {
        if (kind != DefinitionKind.MESSAGE) {
          _error('Cannot deprecate this field', deprecated.line,
              deprecated.column);
        }
        isDeprecated = true;
      }

      expect(semicolon, '";"');

      fields.add(Field(
        name: field.text,
        line: field.line,
        column: field.column,
        type: type,
        isArray: isArray,
        isDeprecated: isDeprecated,
        value: value != null ? int.parse(value.text) : fields.length + 1,
      ));
    }

    definitions.add(Definition(
      name: name.text,
      line: name.line,
      column: name.column,
      kind: kind,
      fields: fields,
    ));
  }

  return Schema(
    package: packageText,
    definitions: definitions,
  );
}

/// Verifies the schema for correctness.
void _verify(Schema root) {
  List<String> definedTypes = List.from(nativeTypes);
  Map<String, Definition> definitions = {};

  // Define definitions
  for (var definition in root.definitions) {
    if (definedTypes.contains(definition.name)) {
      _error('The type ${_quote(definition.name)} is defined twice',
          definition.line, definition.column);
    }
    if (reservedNames.contains(definition.name)) {
      _error('The type name ${_quote(definition.name)} is reserved',
          definition.line, definition.column);
    }
    definedTypes.add(definition.name);
    definitions[definition.name] = definition;
  }

  // Check fields
  for (var definition in root.definitions) {
    var fields = definition.fields;

    if (definition.kind == DefinitionKind.ENUM || fields.isEmpty) {
      continue;
    }

    // Check types
    for (var field in fields) {
      if (!definedTypes.contains(field.type)) {
        _error(
            'The type ${_quote(field.type!)} is not defined for field ${_quote(field.name)}',
            field.line,
            field.column);
      }
    }

    // Check values
    List<int> values = [];
    for (var field in fields) {
      if (values.contains(field.value)) {
        _error('The id for field ${_quote(field.name)} is used twice',
            field.line, field.column);
      }
      if (field.value <= 0) {
        _error('The id for field ${_quote(field.name)} must be positive',
            field.line, field.column);
      }
      if (field.value > fields.length) {
        _error(
            'The id for field ${_quote(field.name)} cannot be larger than ${fields.length}',
            field.line,
            field.column);
      }
      values.add(field.value);
    }
  }

  // Check that structs don't contain themselves
  Map<String, int> state = {};

  void check(String name) {
    var definition = definitions[name];
    if (definition != null && definition.kind == DefinitionKind.STRUCT) {
      if (state[name] == 1) {
        _error('Recursive nesting of ${_quote(name)} is not allowed',
            definition.line, definition.column);
      }
      if (state[name] != 2) {
        state[name] = 1;
        var fields = definition.fields;
        for (var field in fields) {
          if (!field.isArray) {
            check(field.type!);
          }
        }
        state[name] = 2;
      }
    }
  }

  for (var definition in root.definitions) {
    check(definition.name);
  }
}

/// Parses a Kiwi schema from text.
Schema parseSchema(String text) {
  var schema = _parse(_tokenize(text));
  _verify(schema);
  return schema;
}

/// Figma Kiwi Schema support for Dart/Flutter
///
/// This module provides support for encoding and decoding Figma's internal
/// Kiwi binary format, which is used for .fig files and clipboard data.
///
/// Based on the Kiwi schema specification from:
/// https://github.com/gridaco/grida/tree/main/packages/grida-canvas-io-figma/fig-kiwi

library figma;

import 'dart:typed_data';
import 'compiler.dart';
import 'schema.dart';
import 'parser.dart';

/// The Figma Kiwi schema text definition
const String figmaSchemaText = r'''
// Figma Kiwi Schema - Dart/Flutter Port
// Based on Figma's internal Kiwi format specification

// ============================================================================
// ENUMS - Node Types
// ============================================================================

enum NodeType {
  NONE = 0;
  DOCUMENT = 1;
  CANVAS = 2;
  FRAME = 3;
  GROUP = 4;
  VECTOR = 5;
  BOOLEAN_OPERATION = 6;
  STAR = 7;
  LINE = 8;
  ELLIPSE = 9;
  RECTANGLE = 10;
  REGULAR_POLYGON = 11;
  ROUNDED_RECTANGLE = 12;
  TEXT = 13;
  SLICE = 14;
  SYMBOL = 15;
  INSTANCE = 16;
  STICKY = 17;
  SHAPE_WITH_TEXT = 18;
  CONNECTOR = 19;
  CODE_BLOCK = 20;
  WIDGET = 21;
  STAMP = 22;
  MEDIA = 23;
  HIGHLIGHT = 24;
  SECTION = 25;
  SECTION_OVERLAY = 26;
  WASHI_TAPE = 27;
  VARIABLE = 28;
  TABLE = 29;
  TABLE_CELL = 30;
  SLIDE = 31;
  SLIDE_ROW = 32;
  LINK_UNFURL = 33;
  LOTTIE = 34;
  AI_FILE = 35;
  DIAGRAMMING_ELEMENT = 36;
  DIAGRAMMING_CONNECTION = 37;
  COMPONENT = 38;
  COMPONENT_SET = 39;
  EMBED = 40;
}

// ============================================================================
// ENUMS - Paint & Styling
// ============================================================================

enum PaintType {
  SOLID = 0;
  GRADIENT_LINEAR = 1;
  GRADIENT_RADIAL = 2;
  GRADIENT_ANGULAR = 3;
  GRADIENT_DIAMOND = 4;
  IMAGE = 5;
  VIDEO = 6;
  EMOJI = 7;
  PATTERN = 8;
  NOISE = 9;
  EFFECT = 10;
}

enum BlendMode {
  PASS_THROUGH = 0;
  NORMAL = 1;
  DARKEN = 2;
  MULTIPLY = 3;
  COLOR_BURN = 4;
  LIGHTEN = 5;
  SCREEN = 6;
  COLOR_DODGE = 7;
  OVERLAY = 8;
  SOFT_LIGHT = 9;
  HARD_LIGHT = 10;
  DIFFERENCE = 11;
  EXCLUSION = 12;
  HUE = 13;
  SATURATION = 14;
  COLOR = 15;
  LUMINOSITY = 16;
  LINEAR_BURN = 17;
  LINEAR_DODGE = 18;
  PLUS_DARKER = 19;
  PLUS_LIGHTER = 20;
}

enum StrokeAlign {
  CENTER = 0;
  INSIDE = 1;
  OUTSIDE = 2;
}

enum StrokeCap {
  NONE = 0;
  ROUND = 1;
  SQUARE = 2;
  LINE_ARROW = 3;
  TRIANGLE_ARROW = 4;
  DIAMOND_FILLED = 5;
  CIRCLE_FILLED = 6;
  TRIANGLE_FILLED = 7;
  WASHI_TAPE_1 = 8;
  WASHI_TAPE_2 = 9;
  WASHI_TAPE_3 = 10;
  WASHI_TAPE_4 = 11;
  WASHI_TAPE_5 = 12;
  WASHI_TAPE_6 = 13;
}

enum StrokeJoin {
  MITER = 0;
  BEVEL = 1;
  ROUND = 2;
}

enum ImageScaleMode {
  STRETCH = 0;
  FIT = 1;
  FILL = 2;
  TILE = 3;
}

enum EffectType {
  DROP_SHADOW = 0;
  INNER_SHADOW = 1;
  LAYER_BLUR = 2;
  BACKGROUND_BLUR = 3;
  FOREGROUND_BLUR = 4;
}

// ============================================================================
// ENUMS - Layout & Constraints
// ============================================================================

enum StackMode {
  NONE = 0;
  HORIZONTAL = 1;
  VERTICAL = 2;
}

enum StackAlign {
  MIN = 0;
  CENTER = 1;
  MAX = 2;
  BASELINE = 3;
}

enum StackJustify {
  MIN = 0;
  CENTER = 1;
  MAX = 2;
  SPACE_EVENLY = 3;
}

enum StackSize {
  FIXED = 0;
  RESIZE_TO_FIT = 1;
  RESIZE_TO_FIT_WITH_IMPLICIT_SIZE = 2;
}

enum StackPositioning {
  AUTO = 0;
  ABSOLUTE = 1;
}

enum ConstraintType {
  MIN = 0;
  CENTER = 1;
  MAX = 2;
  STRETCH = 3;
  SCALE = 4;
  FIXED_MIN = 5;
  FIXED_MAX = 6;
}

enum LayoutGridType {
  MIN = 0;
  STRETCH = 1;
  CENTER = 2;
}

// ============================================================================
// ENUMS - Text
// ============================================================================

enum TextAlignHorizontal {
  LEFT = 0;
  CENTER = 1;
  RIGHT = 2;
  JUSTIFIED = 3;
}

enum TextAlignVertical {
  TOP = 0;
  CENTER = 1;
  BOTTOM = 2;
}

enum TextAutoResize {
  NONE = 0;
  WIDTH_AND_HEIGHT = 1;
  HEIGHT = 2;
  TRUNCATE = 3;
}

enum TextTruncation {
  DISABLED = 0;
  ENDING = 1;
}

enum TextCase {
  ORIGINAL = 0;
  UPPER = 1;
  LOWER = 2;
  TITLE = 3;
  SMALL_CAPS = 4;
  SMALL_CAPS_FORCED = 5;
}

enum TextDecoration {
  NONE = 0;
  UNDERLINE = 1;
  STRIKETHROUGH = 2;
}

enum LeadingTrim {
  NONE = 0;
  CAP_HEIGHT = 1;
}

enum FontStyle {
  NORMAL = 0;
  ITALIC = 1;
}

enum FontWeight {
  THIN = 100;
  EXTRA_LIGHT = 200;
  LIGHT = 300;
  REGULAR = 400;
  MEDIUM = 500;
  SEMI_BOLD = 600;
  BOLD = 700;
  EXTRA_BOLD = 800;
  BLACK = 900;
}

// ============================================================================
// ENUMS - Boolean Operations
// ============================================================================

enum BooleanOperation {
  UNION = 0;
  INTERSECT = 1;
  SUBTRACT = 2;
  EXCLUDE = 3;
}

// ============================================================================
// ENUMS - Masking
// ============================================================================

enum MaskType {
  NONE = 0;
  OUTLINE = 1;
  ALPHA = 2;
  LUMINANCE = 3;
}

// ============================================================================
// ENUMS - Scroll Behavior
// ============================================================================

enum ScrollBehavior {
  SCROLLS = 0;
  FIXED = 1;
  STICKY = 2;
}

// ============================================================================
// ENUMS - Prototyping
// ============================================================================

enum InteractionType {
  ON_CLICK = 0;
  ON_HOVER = 1;
  ON_PRESS = 2;
  ON_DRAG = 3;
  AFTER_TIMEOUT = 4;
  MOUSE_ENTER = 5;
  MOUSE_LEAVE = 6;
  MOUSE_UP = 7;
  MOUSE_DOWN = 8;
  ON_KEY_DOWN = 9;
}

enum NavigationType {
  NAVIGATE = 0;
  OVERLAY = 1;
  SWAP = 2;
  SCROLL_TO = 3;
  CHANGE_TO = 4;
  OPEN_URL = 5;
  CLOSE = 6;
  BACK = 7;
  SET_VARIABLE = 8;
}

enum TransitionType {
  INSTANT = 0;
  DISSOLVE = 1;
  SMART_ANIMATE = 2;
  SCROLL_ANIMATE = 3;
  MOVE_IN = 4;
  MOVE_OUT = 5;
  PUSH = 6;
  SLIDE_IN = 7;
  SLIDE_OUT = 8;
}

enum TransitionDirection {
  LEFT = 0;
  RIGHT = 1;
  TOP = 2;
  BOTTOM = 3;
}

enum EasingType {
  LINEAR = 0;
  EASE_IN = 1;
  EASE_OUT = 2;
  EASE_IN_OUT = 3;
  EASE_IN_BACK = 4;
  EASE_OUT_BACK = 5;
  EASE_IN_OUT_BACK = 6;
  CUSTOM_BEZIER = 7;
  SPRING = 8;
  GENTLE = 9;
  QUICK = 10;
  BOUNCY = 11;
  SLOW = 12;
  CUSTOM_SPRING = 13;
}

// ============================================================================
// ENUMS - Variables
// ============================================================================

enum VariableDataType {
  BOOLEAN = 0;
  FLOAT = 1;
  STRING = 2;
  COLOR = 3;
  ALIAS = 4;
}

enum VariableScope {
  ALL_SCOPES = 0;
  TEXT_CONTENT = 1;
  CORNER_RADIUS = 2;
  WIDTH_HEIGHT = 3;
  GAP = 4;
  ALL_FILLS = 5;
  FRAME_FILL = 6;
  SHAPE_FILL = 7;
  TEXT_FILL = 8;
  STROKE_COLOR = 9;
  STROKE_FLOAT = 10;
  EFFECT_FLOAT = 11;
  EFFECT_COLOR = 12;
  OPACITY = 13;
  FONT_FAMILY = 14;
  FONT_STYLE = 15;
  FONT_SIZE = 16;
  LINE_HEIGHT = 17;
  LETTER_SPACING = 18;
  PARAGRAPH_SPACING = 19;
  PARAGRAPH_INDENT = 20;
}

// ============================================================================
// ENUMS - Number Units
// ============================================================================

enum NumberUnits {
  RAW = 0;
  PIXELS = 1;
  PERCENT = 2;
}

// ============================================================================
// ENUMS - Export Settings
// ============================================================================

enum ExportFormat {
  PNG = 0;
  JPG = 1;
  SVG = 2;
  PDF = 3;
}

enum ExportConstraintType {
  SCALE = 0;
  WIDTH = 1;
  HEIGHT = 2;
}

// ============================================================================
// STRUCTS - Core Value Types
// ============================================================================

struct GUID {
  uint sessionID;
  uint localID;
}

struct Color {
  float r;
  float g;
  float b;
  float a;
}

struct Vector {
  float x;
  float y;
}

struct Rect {
  float x;
  float y;
  float w;
  float h;
}

struct Matrix {
  float m00;
  float m01;
  float m02;
  float m10;
  float m11;
  float m12;
}

struct Number {
  float value;
  NumberUnits units;
}

struct Size {
  float width;
  float height;
}

// ============================================================================
// STRUCTS - Gradient
// ============================================================================

struct ColorStop {
  float position;
  Color color;
}

struct GradientTransform {
  Vector handlePositionA;
  Vector handlePositionB;
  Vector handlePositionC;
}

// ============================================================================
// STRUCTS - Font
// ============================================================================

struct FontName {
  string family;
  string style;
  string postscript;
}

struct FontVariation {
  uint axisTag;
  float value;
}

struct Glyph {
  uint glyphID;
  int styleID;
  float emojiCodePointsOffset;
  float emojiCodePointsLength;
}

// ============================================================================
// STRUCTS - Path
// ============================================================================

struct VectorVertex {
  float x;
  float y;
  float handleInX;
  float handleInY;
  float handleOutX;
  float handleOutY;
  float cornerRadius;
  bool handleMirroring;
}

struct VectorSegment {
  uint startVertex;
  uint endVertex;
  float tangentStart;
  float tangentEnd;
}

struct VectorRegion {
  uint windingRule;
}

// ============================================================================
// STRUCTS - Layout Grid
// ============================================================================

struct LayoutGrid {
  LayoutGridType type;
  float count;
  float sectionSize;
  bool visible;
  Color color;
  float offset;
  float gutterSize;
}

// ============================================================================
// STRUCTS - Export Settings
// ============================================================================

struct ExportConstraint {
  ExportConstraintType type;
  float value;
}

struct ExportSettingsStruct {
  ExportFormat format;
  ExportConstraint constraint;
  string suffix;
}

// ============================================================================
// MESSAGES - Paint
// ============================================================================

message Paint {
  PaintType type = 1;
  Color color = 2;
  float opacity = 3;
  bool visible = 4;
  BlendMode blendMode = 5;
  ColorStop[] gradientStops = 6;
  GradientTransform gradientTransform = 7;
  ImageScaleMode imageScaleMode = 8;
  float imageSizeX = 9;
  float imageSizeY = 10;
  Matrix imageTransform = 11;
  float rotation = 12;
  float scale = 13;
}

// ============================================================================
// MESSAGES - Effect
// ============================================================================

message Effect {
  EffectType type = 1;
  bool visible = 2;
  Color color = 3;
  BlendMode blendMode = 4;
  Vector offset = 5;
  float radius = 6;
  float spread = 7;
  bool showShadowBehindNode = 8;
}

// ============================================================================
// MESSAGES - Stroke
// ============================================================================

message StrokeWeights {
  float top = 1;
  float right = 2;
  float bottom = 3;
  float left = 4;
}

// ============================================================================
// MESSAGES - Text Data
// ============================================================================

message TextStyle {
  FontName fontName = 1;
  float fontSize = 2;
  float lineHeight = 3;
  float letterSpacing = 4;
  float paragraphSpacing = 5;
  float paragraphIndent = 6;
  TextAlignHorizontal textAlignHorizontal = 7;
  TextAlignVertical textAlignVertical = 8;
  TextCase textCase = 9;
  TextDecoration textDecoration = 10;
  LeadingTrim leadingTrim = 11;
  FontStyle fontStyle = 12;
  FontVariation[] fontVariations = 13;
  Paint[] fills = 14;
  bool hyperlink = 15;
  string hyperlinkURL = 16;
}

message TextData {
  string characters = 1;
  TextStyle[] styleOverrideTable = 2;
  TextAutoResize autoResize = 3;
  TextTruncation truncation = 4;
  uint maxLines = 5;
}

// ============================================================================
// MESSAGES - Vector Data
// ============================================================================

message VectorData {
  VectorVertex[] vertices = 1;
  VectorSegment[] segments = 2;
  VectorRegion[] regions = 3;
  uint vectorNetworkBlob = 4;
}

// ============================================================================
// MESSAGES - Arc Data
// ============================================================================

message ArcData {
  float startingAngle = 1;
  float endingAngle = 2;
  float innerRadius = 3;
}

// ============================================================================
// MESSAGES - Prototype Interaction
// ============================================================================

message Transition {
  TransitionType type = 1;
  TransitionDirection direction = 2;
  float duration = 3;
  EasingType easingType = 4;
}

message Action {
  NavigationType navigationType = 1;
  GUID destinationID = 2;
  string url = 3;
  Transition transition = 4;
  bool preserveScrollPosition = 5;
  Vector scrollOffset = 6;
}

message Interaction {
  InteractionType trigger = 1;
  Action[] actions = 2;
  float delay = 3;
}

// ============================================================================
// MESSAGES - Component Properties
// ============================================================================

message ComponentProperty {
  string key = 1;
  VariableDataType type = 2;
  string defaultValue = 3;
}

message ComponentPropertyAssignment {
  string definitionID = 1;
  string value = 2;
}

// ============================================================================
// MESSAGES - Variable
// ============================================================================

message VariableValue {
  bool boolValue = 1;
  float floatValue = 2;
  string stringValue = 3;
  Color colorValue = 4;
  GUID aliasValue = 5;
}

message Variable {
  GUID id = 1;
  string name = 2;
  VariableDataType dataType = 3;
  VariableValue defaultValue = 4;
}

message VariableCollection {
  GUID id = 1;
  string name = 2;
  string defaultModeID = 3;
  Variable[] variables = 4;
}

// ============================================================================
// MESSAGES - Constraints
// ============================================================================

message Constraints {
  ConstraintType horizontal = 1;
  ConstraintType vertical = 2;
}

// ============================================================================
// MESSAGES - NodeChange (Main Node Data)
// ============================================================================

message NodeChange {
  GUID guid = 1;
  uint phase = 2;
  uint phaseIntention = 3;
  GUID parentGuid = 4;
  NodeType type = 5;
  string name = 6;
  bool visible = 7;
  bool locked = 8;
  float opacity = 9;
  BlendMode blendMode = 10;
  Size size = 11;
  Matrix transform = 12;
  Paint[] fillPaints = 13;
  Paint[] strokePaints = 14;
  float strokeWeight = 15;
  StrokeWeights strokeWeights = 16;
  StrokeAlign strokeAlign = 17;
  StrokeCap strokeCap = 18;
  StrokeJoin strokeJoin = 19;
  float miterLimit = 20;
  float cornerRadius = 21;
  float cornerSmoothing = 22;
  bool clipsContent = 23;
  Effect[] effects = 24;
  bool isMask = 25;
  MaskType maskType = 26;
  bool exportBackgroundDisabled = 27;
  Constraints constraints = 28;
  LayoutGrid[] layoutGrids = 29;
  StackMode stackMode = 30;
  StackAlign stackPrimaryAlign = 31;
  StackAlign stackCounterAlign = 32;
  float stackSpacing = 33;
  float stackPadding = 34;
  float stackPaddingTop = 35;
  float stackPaddingRight = 36;
  float stackPaddingBottom = 37;
  float stackPaddingLeft = 38;
  StackSize stackPrimarySizing = 39;
  StackSize stackCounterSizing = 40;
  StackPositioning stackPositioning = 41;
  ScrollBehavior scrollBehavior = 42;
  TextData textData = 43;
  VectorData vectorData = 44;
  BooleanOperation booleanOperation = 45;
  ArcData arcData = 46;
  uint starPointCount = 47;
  float starInnerRadius = 48;
  uint regularPolygonPointCount = 49;
  GUID componentID = 50;
  ComponentPropertyAssignment[] componentPropertyAssignments = 51;
  Interaction[] interactions = 52;
  bool isFlowStartingPoint = 53;
  string flowStartingPointName = 54;
  float transitionDuration = 55;
  Transition transitionEasing = 56;
  bool useAbsoluteScroll = 57;
  Vector scrollOrigin = 58;
}

// ============================================================================
// MESSAGES - Blob Data
// ============================================================================

message Blob {
  uint index = 1;
}

// ============================================================================
// MESSAGES - Message (Top Level Container)
// ============================================================================

message Message {
  NodeChange[] nodeChanges = 1;
  Blob[] blobs = 2;
  uint blobBaseIndex = 3;
}
''';

/// Parsed Figma schema
late final Schema _figmaSchema = parseSchema(figmaSchemaText);

/// Compiled Figma schema for encoding/decoding
late final CompiledSchema _compiledFigmaSchema = compileSchema(_figmaSchema);

/// Get the parsed Figma schema
Schema get figmaSchema => _figmaSchema;

/// Get the compiled Figma schema for encoding/decoding
CompiledSchema get compiledFigmaSchema => _compiledFigmaSchema;

/// Encode a Figma NodeChange to binary
Uint8List encodeFigmaNodeChange(Map<String, dynamic> nodeChange) {
  return _compiledFigmaSchema.encode('NodeChange', nodeChange);
}

/// Decode a Figma NodeChange from binary
Map<String, dynamic> decodeFigmaNodeChange(Uint8List data) {
  return _compiledFigmaSchema.decode('NodeChange', data);
}

/// Encode a Figma Message to binary
Uint8List encodeFigmaMessage(Map<String, dynamic> message) {
  return _compiledFigmaSchema.encode('Message', message);
}

/// Decode a Figma Message from binary
Map<String, dynamic> decodeFigmaMessage(Uint8List data) {
  return _compiledFigmaSchema.decode('Message', data);
}

/// Encode a Figma Paint to binary
Uint8List encodeFigmaPaint(Map<String, dynamic> paint) {
  return _compiledFigmaSchema.encode('Paint', paint);
}

/// Decode a Figma Paint from binary
Map<String, dynamic> decodeFigmaPaint(Uint8List data) {
  return _compiledFigmaSchema.decode('Paint', data);
}

/// Encode a Figma Effect to binary
Uint8List encodeFigmaEffect(Map<String, dynamic> effect) {
  return _compiledFigmaSchema.encode('Effect', effect);
}

/// Decode a Figma Effect from binary
Map<String, dynamic> decodeFigmaEffect(Uint8List data) {
  return _compiledFigmaSchema.decode('Effect', data);
}

/// Get the Figma NodeType enum values
Map<String, int> get figmaNodeTypeValues =>
    _compiledFigmaSchema.getEnumValues('NodeType')!;

/// Get the Figma NodeType enum names
Map<int, String> get figmaNodeTypeNames =>
    _compiledFigmaSchema.getEnumNames('NodeType')!;

/// Get the Figma BlendMode enum values
Map<String, int> get figmaBlendModeValues =>
    _compiledFigmaSchema.getEnumValues('BlendMode')!;

/// Get the Figma BlendMode enum names
Map<int, String> get figmaBlendModeNames =>
    _compiledFigmaSchema.getEnumNames('BlendMode')!;

/// Get the Figma PaintType enum values
Map<String, int> get figmaPaintTypeValues =>
    _compiledFigmaSchema.getEnumValues('PaintType')!;

/// Get the Figma PaintType enum names
Map<int, String> get figmaPaintTypeNames =>
    _compiledFigmaSchema.getEnumNames('PaintType')!;

/// Get the Figma EffectType enum values
Map<String, int> get figmaEffectTypeValues =>
    _compiledFigmaSchema.getEnumValues('EffectType')!;

/// Get the Figma EffectType enum names
Map<int, String> get figmaEffectTypeNames =>
    _compiledFigmaSchema.getEnumNames('EffectType')!;

import 'dart:typed_data';
import 'byte_buffer.dart';
import 'schema.dart';
import 'parser.dart';

/// A compiled schema that can encode and decode messages.
class CompiledSchema {
  final Schema schema;
  final Map<String, Definition> _definitions = {};
  final Map<String, Map<String, int>> _enumValues = {};
  final Map<String, Map<int, String>> _enumNames = {};

  CompiledSchema(this.schema) {
    for (var definition in schema.definitions) {
      _definitions[definition.name] = definition;

      if (definition.kind == DefinitionKind.ENUM) {
        Map<String, int> valueMap = {};
        Map<int, String> nameMap = {};
        for (var field in definition.fields) {
          valueMap[field.name] = field.value;
          nameMap[field.value] = field.name;
        }
        _enumValues[definition.name] = valueMap;
        _enumNames[definition.name] = nameMap;
      }
    }
  }

  /// Decodes a message of the given type.
  Map<String, dynamic> decode(String typeName, dynamic data) {
    ByteBuffer bb;
    if (data is ByteBuffer) {
      bb = data;
    } else if (data is Uint8List) {
      bb = ByteBuffer(data);
    } else {
      throw ArgumentError('Data must be a ByteBuffer or Uint8List');
    }

    var definition = _definitions[typeName];
    if (definition == null) {
      throw Exception('Unknown type: $typeName');
    }

    return _decodeDefinition(bb, definition);
  }

  /// Encodes a message of the given type.
  Uint8List encode(String typeName, Map<String, dynamic> message) {
    var definition = _definitions[typeName];
    if (definition == null) {
      throw Exception('Unknown type: $typeName');
    }

    ByteBuffer bb = ByteBuffer();
    _encodeDefinition(bb, definition, message);
    return bb.toUint8Array();
  }

  Map<String, dynamic> _decodeDefinition(ByteBuffer bb, Definition definition) {
    Map<String, dynamic> result = {};

    if (definition.kind == DefinitionKind.MESSAGE) {
      while (true) {
        int fieldId = bb.readVarUint();
        if (fieldId == 0) break;

        Field? field;
        for (var f in definition.fields) {
          if (f.value == fieldId) {
            field = f;
            break;
          }
        }

        if (field == null) {
          throw Exception('Attempted to parse invalid message');
        }

        var value = _decodeField(bb, field);
        if (!field.isDeprecated) {
          result[field.name] = value;
        }
      }
    } else {
      // STRUCT
      for (var field in definition.fields) {
        var value = _decodeField(bb, field);
        if (!field.isDeprecated) {
          result[field.name] = value;
        }
      }
    }

    return result;
  }

  dynamic _decodeField(ByteBuffer bb, Field field) {
    if (field.isArray) {
      if (field.type == 'byte') {
        return bb.readByteArray();
      }
      int length = bb.readVarUint();
      List<dynamic> values = [];
      for (int i = 0; i < length; i++) {
        values.add(_decodeValue(bb, field.type!));
      }
      return values;
    } else {
      return _decodeValue(bb, field.type!);
    }
  }

  dynamic _decodeValue(ByteBuffer bb, String type) {
    switch (type) {
      case 'bool':
        return bb.readByte() != 0;
      case 'byte':
        return bb.readByte();
      case 'int':
        return bb.readVarInt();
      case 'uint':
        return bb.readVarUint();
      case 'int64':
        return bb.readVarInt64();
      case 'uint64':
        return bb.readVarUint64();
      case 'float':
        return bb.readVarFloat();
      case 'string':
        return bb.readString();
      default:
        var definition = _definitions[type];
        if (definition == null) {
          throw Exception('Unknown type: $type');
        }
        if (definition.kind == DefinitionKind.ENUM) {
          int value = bb.readVarUint();
          return _enumNames[type]![value];
        } else {
          return _decodeDefinition(bb, definition);
        }
    }
  }

  void _encodeDefinition(
      ByteBuffer bb, Definition definition, Map<String, dynamic> message) {
    if (definition.kind == DefinitionKind.MESSAGE) {
      for (var field in definition.fields) {
        if (field.isDeprecated) continue;

        var value = message[field.name];
        if (value != null) {
          bb.writeVarUint(field.value);
          _encodeField(bb, field, value);
        }
      }
      bb.writeVarUint(0); // End of message
    } else {
      // STRUCT
      for (var field in definition.fields) {
        if (field.isDeprecated) continue;

        var value = message[field.name];
        if (value == null) {
          throw Exception('Missing required field "${field.name}"');
        }
        _encodeField(bb, field, value);
      }
    }
  }

  void _encodeField(ByteBuffer bb, Field field, dynamic value) {
    if (field.isArray) {
      if (field.type == 'byte') {
        bb.writeByteArray(value as Uint8List);
      } else {
        List<dynamic> values = value as List;
        bb.writeVarUint(values.length);
        for (var v in values) {
          _encodeValue(bb, field.type!, v);
        }
      }
    } else {
      _encodeValue(bb, field.type!, value);
    }
  }

  void _encodeValue(ByteBuffer bb, String type, dynamic value) {
    switch (type) {
      case 'bool':
        bb.writeByte(value == true ? 1 : 0);
        break;
      case 'byte':
        bb.writeByte(value as int);
        break;
      case 'int':
        bb.writeVarInt(value as int);
        break;
      case 'uint':
        bb.writeVarUint(value as int);
        break;
      case 'int64':
        bb.writeVarInt64(value as int);
        break;
      case 'uint64':
        bb.writeVarUint64(value as int);
        break;
      case 'float':
        bb.writeVarFloat(value as double);
        break;
      case 'string':
        bb.writeString(value as String);
        break;
      default:
        var definition = _definitions[type];
        if (definition == null) {
          throw Exception('Unknown type: $type');
        }
        if (definition.kind == DefinitionKind.ENUM) {
          var enumValue = _enumValues[type]![value];
          if (enumValue == null) {
            throw Exception('Invalid value "$value" for enum "$type"');
          }
          bb.writeVarUint(enumValue);
        } else {
          // Handle both Map<String, dynamic> and Map<dynamic, dynamic>
          Map<String, dynamic> mapValue;
          if (value is Map<String, dynamic>) {
            mapValue = value;
          } else if (value is Map) {
            mapValue = Map<String, dynamic>.from(value);
          } else {
            throw Exception('Expected a Map for type "$type"');
          }
          _encodeDefinition(bb, definition, mapValue);
        }
    }
  }

  /// Returns the enum value map for a given enum type.
  Map<String, int>? getEnumValues(String enumName) => _enumValues[enumName];

  /// Returns the enum name map for a given enum type.
  Map<int, String>? getEnumNames(String enumName) => _enumNames[enumName];
}

/// Compiles a schema from text.
CompiledSchema compileSchema(dynamic schemaOrText) {
  Schema schema;
  if (schemaOrText is String) {
    schema = parseSchema(schemaOrText);
  } else if (schemaOrText is Schema) {
    schema = schemaOrText;
  } else {
    throw ArgumentError('Expected a Schema or String');
  }
  return CompiledSchema(schema);
}

/// Figma .fig file parser for Dart/Flutter
///
/// This module provides support for reading Figma's .fig file format,
/// which uses the Kiwi binary schema format with compression.
///
/// The file format structure:
/// - Header: "fig-kiwi" (8 bytes) or "fig-kiwie" (9 bytes) + padding
/// - Version/padding to align to 4 bytes
/// - Chunks: Each chunk is [size: uint32_le] + [data: bytes]
///   - Chunk 0: Binary Kiwi schema (may be raw or deflate compressed)
///   - Chunk 1: Message data (ZSTD or deflate compressed)
///   - Chunk 2: Preview image (optional)

library fig_file;

import 'dart:typed_data';
import 'binary.dart';
import 'compiler.dart';
import 'schema.dart';

/// Magic bytes for Figma Kiwi format
const String figKiwiMagic = 'fig-kiwi';
const String figKiwieMagic = 'fig-kiwie';
const String figJamMagic = 'fig-jam.';

/// ZSTD compression signature: 0x28, 0xB5, 0x2F, 0xFD
const List<int> zstdSignature = [0x28, 0xB5, 0x2F, 0xFD];

/// ZLIB compression signature (common variants: 0x78 0x01, 0x78 0x9C, 0x78 0xDA)
const int zlibSignature = 0x78;

/// Deflate (raw) - hard to detect without trying to decompress
/// Figma uses raw deflate for schema chunks

/// Parsed header from a .fig file
class FigHeader {
  final String prelude;
  final int version;

  FigHeader({required this.prelude, required this.version});

  bool get isFigKiwi => prelude == figKiwiMagic || prelude == figKiwieMagic;
  bool get isFigJam => prelude == figJamMagic;

  @override
  String toString() => 'FigHeader(prelude: $prelude, version: $version)';
}

/// Compression type detected in a chunk
enum CompressionType {
  /// No compression detected (raw data)
  none,
  /// ZSTD compression (magic: 0x28 0xB5 0x2F 0xFD)
  zstd,
  /// ZLIB compression (magic: 0x78 ...)
  zlib,
  /// Raw DEFLATE (no header, used by Figma for schema)
  deflate,
  /// Unknown compression
  unknown,
}

/// A chunk from a .fig file
class FigChunk {
  final Uint8List data;
  final CompressionType compression;

  FigChunk({required this.data, required this.compression});

  /// Check if this chunk uses ZSTD compression
  bool get isZstd => compression == CompressionType.zstd;

  /// Check if this chunk uses ZLIB compression
  bool get isZlib => compression == CompressionType.zlib;

  /// Check if this chunk uses raw DEFLATE compression
  bool get isDeflate => compression == CompressionType.deflate;

  /// Check if this chunk is uncompressed
  bool get isRaw => compression == CompressionType.none;
}

/// Result of parsing a .fig file
class FigFile {
  final FigHeader header;
  final FigChunk schemaChunk;
  final FigChunk dataChunk;
  final Uint8List? previewChunk;

  FigFile({
    required this.header,
    required this.schemaChunk,
    required this.dataChunk,
    this.previewChunk,
  });

  @override
  String toString() =>
      'FigFile(header: $header, schemaSize: ${schemaChunk.data.length}, '
      'dataSize: ${dataChunk.data.length}, hasPreview: ${previewChunk != null})';
}

/// Parsed Figma document with decoded schema and message
class ParsedFigFile {
  final FigHeader header;
  final Schema schema;
  final CompiledSchema compiledSchema;
  final Map<String, dynamic> message;
  final Uint8List? preview;

  ParsedFigFile({
    required this.header,
    required this.schema,
    required this.compiledSchema,
    required this.message,
    this.preview,
  });

  /// Get all node changes from the message
  List<Map<String, dynamic>> get nodeChanges {
    final changes = message['nodeChanges'];
    if (changes is List) {
      return changes.cast<Map<String, dynamic>>();
    }
    return [];
  }

  /// Get blobs from the message
  List<Map<String, dynamic>> get blobs {
    final blobList = message['blobs'];
    if (blobList is List) {
      return blobList.cast<Map<String, dynamic>>();
    }
    return [];
  }
}

/// Parser for .fig files
class FigFileParser {
  final Uint8List _data;
  int _offset = 0;

  FigFileParser(this._data);

  /// Read bytes from the buffer
  Uint8List _read(int count) {
    if (_offset + count > _data.length) {
      throw FormatException(
          'Unexpected end of data: need $count bytes at offset $_offset, '
          'but only ${_data.length - _offset} available');
    }
    final result = _data.sublist(_offset, _offset + count);
    _offset += count;
    return result;
  }

  /// Read a little-endian uint32
  int _readUint32() {
    final bytes = _read(4);
    return bytes[0] |
        (bytes[1] << 8) |
        (bytes[2] << 16) |
        (bytes[3] << 24);
  }

  /// Detect compression type from data
  static CompressionType detectCompression(Uint8List data, {bool isSchemaChunk = false}) {
    if (data.length < 4) return CompressionType.unknown;

    // Check ZSTD signature
    if (data[0] == zstdSignature[0] &&
        data[1] == zstdSignature[1] &&
        data[2] == zstdSignature[2] &&
        data[3] == zstdSignature[3]) {
      return CompressionType.zstd;
    }

    // Check ZLIB signature (0x78 followed by 0x01, 0x9C, or 0xDA)
    if (data[0] == zlibSignature &&
        (data[1] == 0x01 || data[1] == 0x9C || data[1] == 0xDA)) {
      return CompressionType.zlib;
    }

    // Schema chunks in Figma use raw deflate (no header)
    if (isSchemaChunk) {
      return CompressionType.deflate;
    }

    // Unknown compression - could be raw deflate or uncompressed
    return CompressionType.unknown;
  }

  /// Parse the .fig file structure
  FigFile parse() {
    // Read prelude
    final preludeBytes = _read(8);
    String prelude = String.fromCharCodes(preludeBytes);

    // Check for fig-kiwie (9 bytes) or other variants
    if (prelude == figKiwiMagic) {
      // Check if it's actually fig-kiwie
      if (_offset < _data.length && _data[_offset] == 0x65) {
        // 'e'
        _read(1); // consume the 'e'
        prelude = figKiwieMagic;
      }
    }

    // Align to 4-byte boundary
    while (_offset % 4 != 0 && _offset < _data.length) {
      _read(1);
    }

    // Validate prelude
    if (prelude != figKiwiMagic &&
        prelude != figKiwieMagic &&
        prelude != figJamMagic) {
      throw FormatException('Invalid fig file prelude: "$prelude"');
    }

    // For fig-kiwie, there's no explicit version field in the new format
    // The chunks start immediately after alignment
    int version = 0;

    // Read chunks
    final chunks = <FigChunk>[];
    while (_offset + 4 <= _data.length) {
      final size = _readUint32();
      if (size == 0 || _offset + size > _data.length) break;

      final chunkData = _read(size);
      // First chunk (schema) uses raw deflate, others may use zstd
      final isSchemaChunk = chunks.isEmpty;
      final compression = detectCompression(chunkData, isSchemaChunk: isSchemaChunk);
      chunks.add(FigChunk(data: chunkData, compression: compression));

      if (chunks.length >= 3) break; // Max 3 chunks expected
    }

    if (chunks.isEmpty) {
      throw FormatException('No chunks found in fig file');
    }

    if (chunks.length < 2) {
      throw FormatException(
          'Expected at least 2 chunks (schema + data), found ${chunks.length}');
    }

    return FigFile(
      header: FigHeader(prelude: prelude, version: version),
      schemaChunk: chunks[0],
      dataChunk: chunks[1],
      previewChunk: chunks.length > 2 ? chunks[2].data : null,
    );
  }
}

/// Callback type for decompressing data
typedef Decompressor = Uint8List Function(Uint8List data);

/// Parse a .fig file with custom decompressors
///
/// Since ZSTD decompression requires native code, you must provide
/// decompressors for the compression types used in your file.
///
/// Example:
/// ```dart
/// import 'package:zstd/zstd.dart' as zstd;
/// import 'dart:io' show zlib;
///
/// final parsed = parseFigFile(
///   data,
///   zstdDecompress: (data) => Uint8List.fromList(zstd.decode(data)),
///   zlibDecompress: (data) => Uint8List.fromList(zlib.decode(data)),
///   deflateDecompress: (data) => Uint8List.fromList(
///     zlib.ZLibDecoder(raw: true).convert(data)),
/// );
/// ```
ParsedFigFile parseFigFile(
  Uint8List data, {
  Decompressor? zstdDecompress,
  Decompressor? zlibDecompress,
  Decompressor? deflateDecompress,
}) {
  final parser = FigFileParser(data);
  final figFile = parser.parse();

  // Decompress schema chunk
  Uint8List schemaData;
  switch (figFile.schemaChunk.compression) {
    case CompressionType.zstd:
      if (zstdDecompress == null) {
        throw UnsupportedError(
            'Schema chunk is ZSTD compressed but no zstdDecompress provided');
      }
      schemaData = zstdDecompress(figFile.schemaChunk.data);
      break;
    case CompressionType.zlib:
      if (zlibDecompress == null) {
        throw UnsupportedError(
            'Schema chunk is ZLIB compressed but no zlibDecompress provided');
      }
      schemaData = zlibDecompress(figFile.schemaChunk.data);
      break;
    case CompressionType.deflate:
      if (deflateDecompress == null) {
        throw UnsupportedError(
            'Schema chunk is DEFLATE compressed but no deflateDecompress provided');
      }
      schemaData = deflateDecompress(figFile.schemaChunk.data);
      break;
    case CompressionType.none:
    case CompressionType.unknown:
      // Assume raw binary schema
      schemaData = figFile.schemaChunk.data;
      break;
  }

  // Decompress data chunk
  Uint8List messageData;
  switch (figFile.dataChunk.compression) {
    case CompressionType.zstd:
      if (zstdDecompress == null) {
        throw UnsupportedError(
            'Data chunk is ZSTD compressed but no zstdDecompress provided');
      }
      messageData = zstdDecompress(figFile.dataChunk.data);
      break;
    case CompressionType.zlib:
      if (zlibDecompress == null) {
        throw UnsupportedError(
            'Data chunk is ZLIB compressed but no zlibDecompress provided');
      }
      messageData = zlibDecompress(figFile.dataChunk.data);
      break;
    case CompressionType.deflate:
      if (deflateDecompress == null) {
        throw UnsupportedError(
            'Data chunk is DEFLATE compressed but no deflateDecompress provided');
      }
      messageData = deflateDecompress(figFile.dataChunk.data);
      break;
    case CompressionType.none:
    case CompressionType.unknown:
      messageData = figFile.dataChunk.data;
      break;
  }

  // Decode binary schema
  final schema = decodeBinarySchema(schemaData);
  final compiledSchema = compileSchema(schema);

  // Decode message
  final message = compiledSchema.decode('Message', messageData);

  return ParsedFigFile(
    header: figFile.header,
    schema: schema,
    compiledSchema: compiledSchema,
    message: message,
    preview: figFile.previewChunk,
  );
}

/// Parse just the file structure without decompressing
FigFile parseFigFileStructure(Uint8List data) {
  final parser = FigFileParser(data);
  return parser.parse();
}

/// Definition kinds for Kiwi schema.
enum DefinitionKind {
  ENUM,
  STRUCT,
  MESSAGE,
}

/// Represents a field in a definition.
class Field {
  final String name;
  final int line;
  final int column;
  String? type;
  final bool isArray;
  final bool isDeprecated;
  final int value;

  Field({
    required this.name,
    this.line = 0,
    this.column = 0,
    this.type,
    this.isArray = false,
    this.isDeprecated = false,
    required this.value,
  });

  Field copyWith({
    String? name,
    int? line,
    int? column,
    String? type,
    bool? isArray,
    bool? isDeprecated,
    int? value,
  }) {
    return Field(
      name: name ?? this.name,
      line: line ?? this.line,
      column: column ?? this.column,
      type: type ?? this.type,
      isArray: isArray ?? this.isArray,
      isDeprecated: isDeprecated ?? this.isDeprecated,
      value: value ?? this.value,
    );
  }

  Map<String, dynamic> toJson() => {
        'name': name,
        'line': line,
        'column': column,
        'type': type,
        'isArray': isArray,
        'isDeprecated': isDeprecated,
        'value': value,
      };
}

/// Represents a definition (enum, struct, or message) in the schema.
class Definition {
  final String name;
  final int line;
  final int column;
  final DefinitionKind kind;
  final List<Field> fields;

  Definition({
    required this.name,
    this.line = 0,
    this.column = 0,
    required this.kind,
    required this.fields,
  });

  Map<String, dynamic> toJson() => {
        'name': name,
        'line': line,
        'column': column,
        'kind': kind.name,
        'fields': fields.map((f) => f.toJson()).toList(),
      };
}

/// Represents a parsed Kiwi schema.
class Schema {
  final String? package;
  final List<Definition> definitions;

  Schema({
    this.package,
    required this.definitions,
  });

  Map<String, dynamic> toJson() => {
        'package': package,
        'definitions': definitions.map((d) => d.toJson()).toList(),
      };
}

/// Flutter renderer for Figma nodes
///
/// This library provides Flutter widgets to render Figma documents.
///
/// Example usage:
/// ```dart
/// import 'package:kiwi_schema/kiwi.dart';
/// import 'package:kiwi_schema/flutter_renderer.dart';
///
/// // Parse a Figma file
/// final parsed = parseFigFile(
///   fileData,
///   zstdDecompress: (data) => zstd.decode(data),
///   deflateDecompress: (data) => zlib.ZLibDecoder(raw: true).convert(data),
/// );
///
/// // Create a document from the parsed message
/// final document = FigmaDocument.fromMessage(parsed.message);
///
/// // Use in a widget
/// FigmaCanvasView(document: document)
/// ```

library flutter_renderer;

export 'node_renderer.dart';
export 'figma_canvas.dart';

/// Flutter node renderer for Figma nodes
///
/// This module provides widgets to render Figma nodes as Flutter widgets,
/// following the structure of grida-canvas-react-renderer-dom.

import 'dart:io';
import 'package:flutter/material.dart';
import 'dart:ui' as ui;

/// Base class for node properties extracted from Figma node data
class FigmaNodeProperties {
  final String? id;
  final String? name;
  final String type;
  final double x;
  final double y;
  final double width;
  final double height;
  final double rotation;
  final double opacity;
  final bool visible;
  final List<Map<String, dynamic>> fills;
  final List<Map<String, dynamic>> strokes;
  final double strokeWeight;
  final List<Map<String, dynamic>> effects;
  final Map<String, dynamic>? constraints;
  final List<double>? cornerRadii;
  final double? cornerRadius;
  final Map<String, dynamic> raw;

  FigmaNodeProperties({
    this.id,
    this.name,
    required this.type,
    this.x = 0,
    this.y = 0,
    this.width = 0,
    this.height = 0,
    this.rotation = 0,
    this.opacity = 1.0,
    this.visible = true,
    this.fills = const [],
    this.strokes = const [],
    this.strokeWeight = 0,
    this.effects = const [],
    this.constraints,
    this.cornerRadii,
    this.cornerRadius,
    required this.raw,
  });

  /// Create properties from a raw Figma node map
  factory FigmaNodeProperties.fromMap(Map<String, dynamic> node) {
    // Extract transform/position
    double x = 0, y = 0, width = 0, height = 0, rotation = 0;

    // Try to get transform from node
    final transform = node['transform'];
    if (transform is Map) {
      x = (transform['m02'] as num?)?.toDouble() ?? 0;
      y = (transform['m12'] as num?)?.toDouble() ?? 0;
    }

    // Try to get size
    final size = node['size'];
    if (size is Map) {
      width = (size['x'] as num?)?.toDouble() ?? 0;
      height = (size['y'] as num?)?.toDouble() ?? 0;
    }

    // Try boundingBox if transform not available
    final bbox = node['boundingBox'];
    if (bbox is Map) {
      x = x == 0 ? ((bbox['x'] as num?)?.toDouble() ?? 0) : x;
      y = y == 0 ? ((bbox['y'] as num?)?.toDouble() ?? 0) : y;
      width = width == 0 ? ((bbox['width'] as num?)?.toDouble() ?? 0) : width;
      height = height == 0 ? ((bbox['height'] as num?)?.toDouble() ?? 0) : height;
    }

    // Extract fills
    List<Map<String, dynamic>> fills = [];
    final fillsData = node['fillPaints'];
    if (fillsData is List) {
      fills = fillsData.cast<Map<String, dynamic>>();
    }

    // Extract strokes
    List<Map<String, dynamic>> strokes = [];
    final strokesData = node['strokePaints'];
    if (strokesData is List) {
      strokes = strokesData.cast<Map<String, dynamic>>();
    }

    // Extract effects
    List<Map<String, dynamic>> effects = [];
    final effectsData = node['effects'];
    if (effectsData is List) {
      effects = effectsData.cast<Map<String, dynamic>>();
    }

    // Extract corner radii
    List<double>? cornerRadii;
    final radii = node['rectangleCornerRadii'];
    if (radii is List) {
      cornerRadii = radii.map((r) => (r as num).toDouble()).toList();
    }

    double? cornerRadius;
    final cr = node['cornerRadius'];
    if (cr is num) {
      cornerRadius = cr.toDouble();
    }

    return FigmaNodeProperties(
      id: node['guid']?.toString(),
      name: node['name'] as String?,
      type: node['type'] as String? ?? 'UNKNOWN',
      x: x,
      y: y,
      width: width,
      height: height,
      rotation: rotation,
      opacity: (node['opacity'] as num?)?.toDouble() ?? 1.0,
      visible: node['visible'] as bool? ?? true,
      fills: fills,
      strokes: strokes,
      strokeWeight: (node['strokeWeight'] as num?)?.toDouble() ?? 0,
      effects: effects,
      constraints: node['constraints'] as Map<String, dynamic>?,
      cornerRadii: cornerRadii,
      cornerRadius: cornerRadius,
      raw: node,
    );
  }

  /// Get the effective corner radius (single value or average of corners)
  double get effectiveCornerRadius {
    if (cornerRadii != null && cornerRadii!.isNotEmpty) {
      return cornerRadii!.first;
    }
    return cornerRadius ?? 0;
  }

  /// Get all corner radii as BorderRadius
  BorderRadius? get borderRadius {
    if (cornerRadii != null && cornerRadii!.length >= 4) {
      return BorderRadius.only(
        topLeft: Radius.circular(cornerRadii![0]),
        topRight: Radius.circular(cornerRadii![1]),
        bottomRight: Radius.circular(cornerRadii![2]),
        bottomLeft: Radius.circular(cornerRadii![3]),
      );
    }
    if (cornerRadius != null && cornerRadius! > 0) {
      return BorderRadius.circular(cornerRadius!);
    }
    return null;
  }
}

/// Convert imageHash bytes to hex string for filename lookup
String imageHashToHex(dynamic imageHash) {
  if (imageHash is List) {
    return imageHash.map((b) => (b as int).toRadixString(16).padLeft(2, '0')).join();
  }
  return '';
}

/// Global debug flag for Figma renderer - set to true to enable verbose logging
bool figmaRendererDebug = false; // Disabled

/// Tracks which node types have been logged (to reduce log spam)
Set<String>? _loggedRenderTypes;

/// Main node renderer widget that routes to specific renderers based on node type
class FigmaNodeWidget extends StatelessWidget {
  final Map<String, dynamic> node;
  final Map<String, Map<String, dynamic>>? nodeMap;
  final Map<String, List<int>>? blobMap;
  final String? imagesDirectory;
  final double scale;
  final bool showBounds;
  /// Property overrides from parent INSTANCE's symbolOverrides
  final Map<String, dynamic>? propertyOverrides;
  /// Full override map from parent INSTANCE for nested children lookup
  final Map<String, Map<String, dynamic>>? instanceOverrides;

  const FigmaNodeWidget({
    super.key,
    required this.node,
    this.nodeMap,
    this.blobMap,
    this.imagesDirectory,
    this.scale = 1.0,
    this.showBounds = false,
    this.propertyOverrides,
    this.instanceOverrides,
  });

  @override
  Widget build(BuildContext context) {
    // Look up overrides for this node from instanceOverrides if not directly provided
    Map<String, dynamic>? effectiveOverrides = propertyOverrides;
    if (effectiveOverrides == null && instanceOverrides != null) {
      final nodeKey = node['_guidKey']?.toString();
      if (nodeKey != null) {
        effectiveOverrides = instanceOverrides![nodeKey];
      }
    }

    // Apply property overrides if present (from parent INSTANCE's symbolOverrides)
    Map<String, dynamic> effectiveNode = node;
    if (effectiveOverrides != null && effectiveOverrides.isNotEmpty) {
      effectiveNode = Map<String, dynamic>.from(node);
      // Merge overrides into the node
      effectiveOverrides.forEach((key, value) {
        if (value != null) {
          effectiveNode[key] = value;
        }
      });
    }

    final props = FigmaNodeProperties.fromMap(effectiveNode);

    if (!props.visible) {
      return const SizedBox.shrink();
    }

    final type = props.type;

    // Debug: Log which nodes are being rendered (only once per type to reduce spam)
    if (figmaRendererDebug) {
      // Use static set to track which types we've already logged
      _loggedRenderTypes ??= <String>{};
      if (!_loggedRenderTypes!.contains(type)) {
        _loggedRenderTypes!.add(type);
        print('DEBUG RENDER: First "$type" node: "${props.name}"');
      }
    }

    Widget child;
    switch (type) {
      case 'FRAME':
      case 'GROUP':
      case 'COMPONENT':
      case 'COMPONENT_SET':
        // Debug: Log structure of key frames (limit to specific names to reduce spam)
        if (figmaRendererDebug &&
            (props.name == 'ðŸ“˜ Components Index' ||
             props.name == 'Similar Files' ||
             props.name?.contains('Thumbnail') == true ||
             (props.name == 'Content' && props.width > 2000) ||
             props.name == 'Section' ||
             props.name == 'Cover and Text' ||
             props.name == 'Cover' ||
             props.name == 'Cropping Device' ||
             props.name == 'Device' ||
             props.name == 'Crop Screen')) {
          final ownFills = props.fills;
          final hasOwnImage = ownFills.any((f) => f['type'] == 'IMAGE');
          final isMask = props.raw['mask'] == true || props.raw['isMask'] == true;
          final hasMask = props.raw['hasMask'] == true;
          final maskType = props.raw['maskType'];
          final clipsContent = props.raw['clipsContent'] == true;
          print('DEBUG FRAME: "${props.name}" (${props.type}, ${props.width}x${props.height})${hasOwnImage ? " [IMAGE]" : ""}${isMask ? " [IS_MASK]" : ""}${hasMask ? " [HAS_MASK]" : ""}${clipsContent ? " [CLIPS]" : ""}${maskType != null ? " [maskType=$maskType]" : ""}');
          final children = props.raw['children'] as List? ?? [];
          for (int i = 0; i < children.length && i < 15; i++) {
            final childKey = children[i].toString();
            final childNode = nodeMap?[childKey];
            if (childNode != null) {
              final childName = childNode['name'];
              final childType = childNode['type'];
              final childChildren = (childNode['children'] as List?)?.length ?? 0;
              final fills = childNode['fillPaints'] as List? ?? [];
              final hasImageFill = fills.any((f) => f['type'] == 'IMAGE');
              print('  [$i] "$childName" ($childType, $childChildren ch)${hasImageFill ? " [HAS IMAGE]" : ""}');

              // Also show grandchildren for Section rows
              if (props.name == 'Section' && childType == 'FRAME' && childChildren > 0) {
                final grandKids = childNode['children'] as List? ?? [];
                for (int j = 0; j < grandKids.length && j < 5; j++) {
                  final gkKey = grandKids[j].toString();
                  final gkNode = nodeMap?[gkKey];
                  if (gkNode != null) {
                    final gkName = gkNode['name'];
                    final gkType = gkNode['type'];
                    final gkFills = gkNode['fillPaints'] as List? ?? [];
                    final gkHasImage = gkFills.any((f) => f['type'] == 'IMAGE');
                    print('      [$j] "$gkName" ($gkType)${gkHasImage ? " [HAS IMAGE]" : ""}');
                  }
                }
              }
            }
          }
        }
        child = FigmaFrameWidget(props: props, nodeMap: nodeMap, blobMap: blobMap, imagesDirectory: imagesDirectory, scale: scale, instanceOverrides: instanceOverrides);
        break;
      case 'INSTANCE':
        // INSTANCE nodes reference a COMPONENT via symbolData - resolve it
        child = FigmaInstanceWidget(
          props: props,
          nodeMap: nodeMap,
          blobMap: blobMap,
          imagesDirectory: imagesDirectory,
          scale: scale,
        );
        break;
      case 'SYMBOL':
      case 'SECTION':
        child = FigmaFrameWidget(props: props, nodeMap: nodeMap, blobMap: blobMap, imagesDirectory: imagesDirectory, scale: scale, instanceOverrides: instanceOverrides);
        break;
      case 'RECTANGLE':
      case 'ROUNDED_RECTANGLE':
        // Check if this rectangle has IMAGE fills - if so, use FigmaFrameWidget which handles images
        final hasImageFill = props.fills.any((fill) => fill['type'] == 'IMAGE');
        if (hasImageFill) {
          child = FigmaFrameWidget(props: props, nodeMap: nodeMap, blobMap: blobMap, imagesDirectory: imagesDirectory, scale: scale, instanceOverrides: instanceOverrides);
        } else {
          child = FigmaRectangleWidget(props: props);
        }
        break;
      case 'ELLIPSE':
        child = FigmaEllipseWidget(props: props);
        break;
      case 'TEXT':
        child = FigmaTextWidget(props: props, scale: scale, effectiveNode: effectiveNode);
        break;
      case 'VECTOR':
      case 'LINE':
      case 'STAR':
      case 'POLYGON':
      case 'BOOLEAN_OPERATION':
        child = FigmaVectorWidget(props: props);
        break;
      case 'CANVAS':
        // Canvas is a page - render its children (no instanceOverrides at page level)
        child = FigmaCanvasWidget(props: props, nodeMap: nodeMap, blobMap: blobMap, imagesDirectory: imagesDirectory, scale: scale);
        break;
      case 'DOCUMENT':
        // Document is the root - skip rendering
        child = const SizedBox.shrink();
        break;
      default:
        // Fallback for unknown types - log what we're missing
        print('DEBUG UNKNOWN TYPE: ${props.type} "${props.name}"');
        child = FigmaPlaceholderWidget(props: props);
    }

    // Wrap with transform if needed
    if (props.rotation != 0) {
      child = Transform.rotate(
        angle: props.rotation * 3.14159265359 / 180,
        child: child,
      );
    }

    // Apply opacity
    if (props.opacity < 1.0) {
      child = Opacity(opacity: props.opacity, child: child);
    }

    // Debug bounds
    if (showBounds) {
      child = Stack(
        children: [
          child,
          Positioned.fill(
            child: IgnorePointer(
              child: Container(
                decoration: BoxDecoration(
                  border: Border.all(color: const Color(0x80FF0000), width: 1), // red with 0.5 opacity
                ),
              ),
            ),
          ),
        ],
      );
    }

    // Wrap with debug overlay for inspection
    return DebugNodeWrapper(
      node: node,
      scale: scale,
      child: child,
    );
  }
}

/// Frame/Group/Component renderer
class FigmaFrameWidget extends StatelessWidget {
  final FigmaNodeProperties props;
  final Map<String, Map<String, dynamic>>? nodeMap;
  final Map<String, List<int>>? blobMap;
  final String? imagesDirectory;
  final double scale;
  final Map<String, Map<String, dynamic>>? instanceOverrides;

  const FigmaFrameWidget({
    super.key,
    required this.props,
    this.nodeMap,
    this.blobMap,
    this.imagesDirectory,
    this.scale = 1.0,
    this.instanceOverrides,
  });

  @override
  Widget build(BuildContext context) {
    // Check for IMAGE fills first
    Widget? imageWidget;

    // Also check raw node for other fill fields
    final rawFills = props.raw['fills'];

    // Debug disabled - focusing on IMAGE fills only

    // Try multiple fill field names Figma might use
    final allFills = <Map<String, dynamic>>[
      ...props.fills, // fillPaints
      if (rawFills is List) ...rawFills.whereType<Map<String, dynamic>>(),
    ];

    // Check imagePaints specifically (Figma often separates image paints)
    final imagePaints = props.raw['imagePaints'];
    if (imagePaints is List) {
      for (final paint in imagePaints) {
        if (paint is Map<String, dynamic>) {
          allFills.add(paint);
        }
      }
    }

    // Check backgroundPaints
    final backgroundPaints = props.raw['backgroundPaints'];
    if (backgroundPaints is List) {
      for (final paint in backgroundPaints) {
        if (paint is Map<String, dynamic>) {
          allFills.add(paint);
        }
      }
    }

    // Debug: Log all fill types being processed
    if (figmaRendererDebug && allFills.isNotEmpty) {
      final fillTypes = allFills.map((f) => f['type']).toSet().toList();
      if (fillTypes.any((t) => t == 'IMAGE')) {
        print('DEBUG FILLS: "${props.name}" has ${allFills.length} fills: $fillTypes');
      }
    }

    for (final fill in allFills) {
      if (fill['visible'] == false) continue;
      final fillType = fill['type'];

      if (fillType == 'IMAGE') {
        // Debug logging (controlled by flag)
        if (figmaRendererDebug) {
          print('DEBUG IMAGE: "${props.name}" FILL_KEYS=${fill.keys.toList()}');
        }

        // Extract image reference - Figma stores it in fill['image']['hash']
        dynamic imageRef = fill['image'] ??
                           fill['imageHash'] ??
                           fill['imageRef'] ??
                           fill['hash'];

        if (imageRef != null && imagesDirectory != null) {
          String hexHash = '';

          if (imageRef is Map) {
            // Image is stored as {hash: [...bytes...], name: "..."}
            final bytes = imageRef['hash'] ?? imageRef['bytes'];
            if (bytes is List) {
              hexHash = imageHashToHex(bytes);
            }
          } else if (imageRef is List) {
            hexHash = imageHashToHex(imageRef);
          } else if (imageRef is String) {
            hexHash = imageRef;
          }

          if (hexHash.isNotEmpty) {
            final imagePath = '$imagesDirectory/$hexHash';
            final file = File(imagePath);
            if (file.existsSync()) {
              if (figmaRendererDebug) {
                print('DEBUG IMAGE: Loading ${props.width}x${props.height} from $hexHash');
              }
              imageWidget = Image.file(
                file,
                width: props.width * scale,
                height: props.height * scale,
                fit: BoxFit.cover,
                errorBuilder: (context, error, stackTrace) {
                  if (figmaRendererDebug) {
                    print('DEBUG IMAGE ERROR: $error');
                  }
                  return Container(
                    color: Colors.grey[300],
                    child: const Icon(Icons.broken_image),
                  );
                },
              );
              break;
            } else if (figmaRendererDebug) {
              print('DEBUG IMAGE: File not found: $imagePath');
            }
          }
        }
      }
    }

    // Get background from fills (non-image fills)
    final decoration = _buildDecoration();

    // Build children
    final children = _buildChildren();

    final clipsContent = props.raw['clipsContent'] == true;

    Widget content = Container(
      width: props.width * scale,
      height: props.height * scale,
      decoration: decoration,
      clipBehavior: clipsContent ? Clip.hardEdge : Clip.none,
      child: children.isEmpty
          ? null
          : Stack(
              clipBehavior: clipsContent ? Clip.hardEdge : Clip.none,
              children: children,
            ),
    );

    // Always clip frames to prevent content overflow (Figma behavior)
    // This ensures children don't render outside frame bounds
    if (children.isNotEmpty) {
      content = ClipRRect(
        borderRadius: props.borderRadius ?? BorderRadius.zero,
        child: content,
      );
    }

    // If we have an image, stack it behind the content
    if (imageWidget != null) {
      content = Stack(
        children: [
          ClipRRect(
            borderRadius: props.borderRadius ?? BorderRadius.zero,
            child: imageWidget,
          ),
          content,
        ],
      );
    }

    // Wrap large frames in RepaintBoundary for better pan/zoom performance
    if (props.width > 200 && props.height > 200) {
      return RepaintBoundary(child: content);
    }

    return content;
  }

  BoxDecoration _buildDecoration() {
    Color? backgroundColor;
    Gradient? gradient;

    for (final fill in props.fills) {
      if (fill['visible'] == false) continue;

      final fillType = fill['type'];
      if (fillType == 'SOLID') {
        final color = fill['color'];
        if (color is Map) {
          backgroundColor = Color.fromRGBO(
            ((color['r'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
            ((color['g'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
            ((color['b'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
            (color['a'] as num?)?.toDouble() ?? 1.0,
          );
        }
      } else if (fillType == 'GRADIENT_LINEAR' || fillType == 'GRADIENT_RADIAL') {
        gradient = _buildGradient(fill);
      }
    }

    // Build border from strokes
    Border? border;
    if (props.strokes.isNotEmpty && props.strokeWeight > 0) {
      final stroke = props.strokes.first;
      if (stroke['visible'] != false) {
        final color = stroke['color'];
        if (color is Map) {
          border = Border.all(
            color: Color.fromRGBO(
              ((color['r'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
              ((color['g'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
              ((color['b'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
              (color['a'] as num?)?.toDouble() ?? 1.0,
            ),
            width: props.strokeWeight * scale,
          );
        }
      }
    }

    // Build shadow from effects
    List<BoxShadow>? shadows;
    for (final effect in props.effects) {
      if (effect['visible'] == false) continue;
      final effectType = effect['type'];
      if (effectType == 'DROP_SHADOW' || effectType == 'INNER_SHADOW') {
        final color = effect['color'];
        if (color is Map) {
          shadows ??= [];
          shadows.add(BoxShadow(
            color: Color.fromRGBO(
              ((color['r'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
              ((color['g'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
              ((color['b'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
              (color['a'] as num?)?.toDouble() ?? 0.25,
            ),
            blurRadius: ((effect['radius'] as num?)?.toDouble() ?? 0) * scale,
            offset: Offset(
              ((effect['offset']?['x'] as num?)?.toDouble() ?? 0) * scale,
              ((effect['offset']?['y'] as num?)?.toDouble() ?? 0) * scale,
            ),
          ));
        }
      }
    }

    return BoxDecoration(
      color: gradient == null ? backgroundColor : null,
      gradient: gradient,
      border: border,
      borderRadius: props.borderRadius,
      boxShadow: shadows,
    );
  }

  Gradient? _buildGradient(Map<String, dynamic> fill) {
    final stops = fill['gradientStops'] as List?;
    if (stops == null || stops.isEmpty) return null;

    final colors = <Color>[];
    final stopPositions = <double>[];

    for (final stop in stops) {
      final color = stop['color'];
      if (color is Map) {
        colors.add(Color.fromRGBO(
          ((color['r'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
          ((color['g'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
          ((color['b'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
          (color['a'] as num?)?.toDouble() ?? 1.0,
        ));
        stopPositions.add((stop['position'] as num?)?.toDouble() ?? 0);
      }
    }

    if (colors.length < 2) return null;

    final fillType = fill['type'];
    if (fillType == 'GRADIENT_LINEAR') {
      return LinearGradient(colors: colors, stops: stopPositions);
    } else if (fillType == 'GRADIENT_RADIAL') {
      return RadialGradient(colors: colors, stops: stopPositions);
    }
    return null;
  }

  List<Widget> _buildChildren() {
    if (nodeMap == null) return [];

    final childrenKeys = props.raw['children'] as List?;
    if (childrenKeys == null) return [];

    final children = <Widget>[];
    // In Figma, the first child in the array is visually on TOP
    // In Flutter Stack, the last child added is on TOP
    // So we REVERSE the order to match Figma's z-order
    final reversedKeys = childrenKeys.reversed.toList();
    for (final childKey in reversedKeys) {
      // childKey is now a String key like "0:123"
      final childNode = nodeMap![childKey.toString()];
      if (childNode != null) {
        final childProps = FigmaNodeProperties.fromMap(childNode);
        // Only render visible children
        if (!childProps.visible) continue;

        children.add(
          Positioned(
            left: childProps.x * scale,
            top: childProps.y * scale,
            child: FigmaNodeWidget(
              node: childNode,
              nodeMap: nodeMap,
              blobMap: blobMap,
              imagesDirectory: imagesDirectory,
              scale: scale,
              instanceOverrides: instanceOverrides,
            ),
          ),
        );
      }
    }
    return children;
  }

  /// Build children for auto-layout frames with calculated positions
  List<Widget> _buildAutoLayoutPositionedChildren(List childrenKeys, dynamic layoutMode) {
    final isVertical = layoutMode == 'VERTICAL' || layoutMode == 1;
    final itemSpacing = ((props.raw['itemSpacing'] as num?)?.toDouble() ?? 0) * scale;
    final paddingLeft = ((props.raw['stackPaddingLeft'] as num?)?.toDouble() ?? 0) * scale;
    final paddingTop = ((props.raw['stackPaddingTop'] as num?)?.toDouble() ?? 0) * scale;

    final children = <Widget>[];
    double currentOffset = isVertical ? paddingTop : paddingLeft;

    // Auto-layout uses natural order (first = top/left)
    for (final childKey in childrenKeys) {
      final childNode = nodeMap![childKey.toString()];
      if (childNode != null) {
        final childProps = FigmaNodeProperties.fromMap(childNode);
        if (!childProps.visible) continue;

        final left = isVertical ? paddingLeft : currentOffset;
        final top = isVertical ? currentOffset : paddingTop;

        children.add(
          Positioned(
            left: left,
            top: top,
            child: FigmaNodeWidget(
              node: childNode,
              nodeMap: nodeMap,
              blobMap: blobMap,
              imagesDirectory: imagesDirectory,
              scale: scale,
              instanceOverrides: instanceOverrides,
            ),
          ),
        );

        // Advance position for next child
        if (isVertical) {
          currentOffset += childProps.height * scale + itemSpacing;
        } else {
          currentOffset += childProps.width * scale + itemSpacing;
        }
      }
    }
    return children;
  }

  /// Build children for auto-layout (flexbox) frames
  Widget _buildAutoLayoutChildren() {
    if (nodeMap == null) return const SizedBox.shrink();

    final childrenKeys = props.raw['children'] as List?;
    if (childrenKeys == null || childrenKeys.isEmpty) return const SizedBox.shrink();

    final layoutMode = props.raw['stackMode'] ?? props.raw['layoutMode'];
    final isVertical = layoutMode == 'VERTICAL' || layoutMode == 1;
    final itemSpacing = ((props.raw['itemSpacing'] as num?)?.toDouble() ?? 0) * scale;

    // Get alignment
    final primaryAlign = props.raw['stackPrimaryAlignItems'] ?? props.raw['primaryAxisAlignItems'];
    final counterAlign = props.raw['stackCounterAlignItems'] ?? props.raw['counterAxisAlignItems'];

    MainAxisAlignment mainAxis = MainAxisAlignment.start;
    if (primaryAlign == 'CENTER' || primaryAlign == 1) {
      mainAxis = MainAxisAlignment.center;
    } else if (primaryAlign == 'MAX' || primaryAlign == 2) {
      mainAxis = MainAxisAlignment.end;
    } else if (primaryAlign == 'SPACE_BETWEEN' || primaryAlign == 3) {
      mainAxis = MainAxisAlignment.spaceBetween;
    }

    CrossAxisAlignment crossAxis = CrossAxisAlignment.start;
    if (counterAlign == 'CENTER' || counterAlign == 1) {
      crossAxis = CrossAxisAlignment.center;
    } else if (counterAlign == 'MAX' || counterAlign == 2) {
      crossAxis = CrossAxisAlignment.end;
    }

    // Get padding
    final paddingLeft = ((props.raw['stackPaddingLeft'] as num?)?.toDouble() ?? 0) * scale;
    final paddingRight = ((props.raw['stackPaddingRight'] as num?)?.toDouble() ?? 0) * scale;
    final paddingTop = ((props.raw['stackPaddingTop'] as num?)?.toDouble() ?? 0) * scale;
    final paddingBottom = ((props.raw['stackPaddingBottom'] as num?)?.toDouble() ?? 0) * scale;

    // Build child widgets (NOT reversed for auto-layout - natural order)
    final childWidgets = <Widget>[];
    for (int i = 0; i < childrenKeys.length; i++) {
      final childKey = childrenKeys[i].toString();
      final childNode = nodeMap![childKey];
      if (childNode != null) {
        final childProps = FigmaNodeProperties.fromMap(childNode);
        if (!childProps.visible) continue;

        if (childWidgets.isNotEmpty && itemSpacing > 0) {
          childWidgets.add(SizedBox(
            width: isVertical ? 0 : itemSpacing,
            height: isVertical ? itemSpacing : 0,
          ));
        }

        childWidgets.add(
          FigmaNodeWidget(
            node: childNode,
            nodeMap: nodeMap,
            blobMap: blobMap,
            imagesDirectory: imagesDirectory,
            scale: scale,
            instanceOverrides: instanceOverrides,
          ),
        );
      }
    }

    Widget layout;
    if (isVertical) {
      layout = Column(
        mainAxisSize: MainAxisSize.min,
        mainAxisAlignment: mainAxis,
        crossAxisAlignment: crossAxis,
        children: childWidgets,
      );
    } else {
      layout = Row(
        mainAxisSize: MainAxisSize.min,
        mainAxisAlignment: mainAxis,
        crossAxisAlignment: crossAxis,
        children: childWidgets,
      );
    }

    if (paddingLeft > 0 || paddingRight > 0 || paddingTop > 0 || paddingBottom > 0) {
      layout = Padding(
        padding: EdgeInsets.only(
          left: paddingLeft,
          right: paddingRight,
          top: paddingTop,
          bottom: paddingBottom,
        ),
        child: layout,
      );
    }

    // Clip overflow - auto-layout content can exceed bounds
    return ClipRect(child: layout);
  }

  /// Check if this frame uses auto-layout
  bool get _isAutoLayout {
    final layoutMode = props.raw['stackMode'] ?? props.raw['layoutMode'];
    return layoutMode != null && layoutMode != 'NONE' && layoutMode != 0;
  }
}

/// Instance renderer - resolves component reference via symbolData
class FigmaInstanceWidget extends StatelessWidget {
  final FigmaNodeProperties props;
  final Map<String, Map<String, dynamic>>? nodeMap;
  final Map<String, List<int>>? blobMap;
  final String? imagesDirectory;
  final double scale;

  const FigmaInstanceWidget({
    super.key,
    required this.props,
    this.nodeMap,
    this.blobMap,
    this.imagesDirectory,
    this.scale = 1.0,
  });

  @override
  Widget build(BuildContext context) {
    // Try to resolve the source component via symbolData
    Map<String, dynamic>? sourceComponent;

    final symbolData = props.raw['symbolData'];
    List<dynamic>? symbolOverrides;
    if (symbolData is Map && nodeMap != null) {
      final symbolId = symbolData['symbolID'];
      final rawOverrides = symbolData['symbolOverrides'];
      symbolOverrides = rawOverrides is List ? rawOverrides : null;
      if (symbolId is Map) {
        // Convert GUID to key format: "sessionID:localID"
        final sessionId = symbolId['sessionID'] ?? 0;
        final localId = symbolId['localID'] ?? 0;
        final symbolKey = '$sessionId:$localId';
        sourceComponent = nodeMap![symbolKey];

        if (figmaRendererDebug && sourceComponent != null) {
          final srcName = sourceComponent['name'];
          final srcType = sourceComponent['type'];
          final srcChildren = sourceComponent['children'] as List? ?? [];
          print('DEBUG INSTANCE: "${props.name}" â†’ resolved "$srcName" ($srcType, ${srcChildren.length} children)');
          // Log ALL instances with symbolOverrides to understand the format
          if (symbolOverrides != null && symbolOverrides.isNotEmpty) {
            print('  symbolOverrides: ${symbolOverrides.length} items');
            for (int i = 0; i < symbolOverrides.length && i < 2; i++) {
              final override = symbolOverrides[i];
              if (override is Map) {
                print('  override[$i] keys: ${override.keys.toList()}');
                // Show guidPath if present (identifies which node to override)
                if (override.containsKey('guidPath')) {
                  final guidPath = override['guidPath'];
                  print('    guidPath: $guidPath');
                }
                // Show fillPaints if present (IMAGE overrides)
                if (override.containsKey('fillPaints')) {
                  final fills = override['fillPaints'] as List?;
                  if (fills != null && fills.isNotEmpty) {
                    final fillTypes = fills.map((f) => f['type']).toList();
                    print('    fillPaints: $fillTypes');
                    for (final f in fills) {
                      if (f['type'] == 'IMAGE' && f['image'] != null) {
                        final hash = f['image']['hash'];
                        if (hash is List) {
                          print('    IMAGE: ${imageHashToHex(hash)}');
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Build decoration from instance's own fills/strokes
    final decoration = _buildDecoration();

    // Get children - either from instance's own children or from source component
    List<String> childrenKeys = [];

    // First check instance's own children
    final instanceChildren = props.raw['children'] as List?;
    if (instanceChildren != null && instanceChildren.isNotEmpty) {
      childrenKeys = instanceChildren.map((e) => e.toString()).toList();
    }
    // If no children, use source component's children
    else if (sourceComponent != null) {
      final srcChildren = sourceComponent['children'] as List?;
      if (srcChildren != null) {
        childrenKeys = srcChildren.map((e) => e.toString()).toList();
      }
    }

    // Build override map from symbolOverrides
    // Each override has a guidPath that identifies which nested node to override
    final overrideMap = <String, Map<String, dynamic>>{};
    if (symbolOverrides != null) {
      // Debug: log first few overrides to understand structure
      if (figmaRendererDebug && symbolOverrides.isNotEmpty) {
        print('DEBUG OVERRIDES for "${props.name}": ${symbolOverrides.length} overrides');
        for (int i = 0; i < symbolOverrides.length && i < 3; i++) {
          final o = symbolOverrides[i];
          if (o is Map) {
            print('  [$i] keys: ${o.keys.toList()}');
            if (o.containsKey('textData')) {
              final td = o['textData'];
              if (td is Map) {
                print('      textData.characters: "${td['characters']}"');
              }
            }
            if (o.containsKey('characters')) {
              print('      characters: "${o['characters']}"');
            }
          }
        }
      }

      for (final override in symbolOverrides) {
        if (override is Map) {
          final guidPath = override['guidPath'];
          if (guidPath is Map) {
            // guidPath is a GUID - convert to key
            final sessionId = guidPath['sessionID'] ?? 0;
            final localId = guidPath['localID'] ?? 0;
            final overrideKey = '$sessionId:$localId';
            // Store the override properties (excluding guidPath itself)
            final overrideProps = Map<String, dynamic>.from(override);
            overrideProps.remove('guidPath');
            overrideMap[overrideKey] = overrideProps;
          } else if (guidPath is List && guidPath.isNotEmpty) {
            // guidPath is a list of GUIDs - use the last one (target node)
            final targetGuid = guidPath.last;
            if (targetGuid is Map) {
              final sessionId = targetGuid['sessionID'] ?? 0;
              final localId = targetGuid['localID'] ?? 0;
              final overrideKey = '$sessionId:$localId';
              final overrideProps = Map<String, dynamic>.from(override);
              overrideProps.remove('guidPath');
              overrideMap[overrideKey] = overrideProps;
            }
          }
        }
      }
    }

    // Build child widgets (reversed order for correct z-order)
    final children = <Widget>[];
    if (nodeMap != null) {
      // Reverse order: Figma's first child = top, Flutter Stack's last = top
      final reversedKeys = childrenKeys.reversed.toList();
      for (final childKey in reversedKeys) {
        final childNode = nodeMap![childKey];
        if (childNode != null) {
          final childProps = FigmaNodeProperties.fromMap(childNode);
          if (!childProps.visible) continue;

          // Check if there's an override for this child
          final childOverride = overrideMap[childKey];

          children.add(
            Positioned(
              left: childProps.x * scale,
              top: childProps.y * scale,
              child: FigmaNodeWidget(
                node: childNode,
                nodeMap: nodeMap,
                blobMap: blobMap,
                imagesDirectory: imagesDirectory,
                scale: scale,
                propertyOverrides: childOverride,
                instanceOverrides: overrideMap, // Pass full map for nested lookups
              ),
            ),
          );
        }
      }
    }

    return Container(
      width: props.width * scale,
      height: props.height * scale,
      decoration: decoration,
      clipBehavior: props.raw['clipsContent'] == true ? Clip.hardEdge : Clip.none,
      child: children.isEmpty
          ? null
          : Stack(
              clipBehavior: Clip.none,
              children: children,
            ),
    );
  }

  BoxDecoration _buildDecoration() {
    Color? backgroundColor;

    for (final fill in props.fills) {
      if (fill['visible'] == false) continue;
      final fillType = fill['type'];
      if (fillType == 'SOLID') {
        final color = fill['color'];
        if (color is Map) {
          backgroundColor = Color.fromRGBO(
            ((color['r'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
            ((color['g'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
            ((color['b'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
            (color['a'] as num?)?.toDouble() ?? 1.0,
          );
        }
      }
    }

    return BoxDecoration(
      color: backgroundColor,
      borderRadius: props.borderRadius,
    );
  }
}

/// Rectangle renderer
class FigmaRectangleWidget extends StatelessWidget {
  final FigmaNodeProperties props;

  const FigmaRectangleWidget({super.key, required this.props});

  @override
  Widget build(BuildContext context) {
    return CustomPaint(
      size: Size(props.width, props.height),
      painter: _RectanglePainter(props: props),
    );
  }
}

class _RectanglePainter extends CustomPainter {
  final FigmaNodeProperties props;

  _RectanglePainter({required this.props});

  @override
  void paint(Canvas canvas, Size size) {
    final rect = Rect.fromLTWH(0, 0, size.width, size.height);
    RRect rrect;

    if (props.cornerRadii != null && props.cornerRadii!.length >= 4) {
      rrect = RRect.fromRectAndCorners(
        rect,
        topLeft: Radius.circular(props.cornerRadii![0]),
        topRight: Radius.circular(props.cornerRadii![1]),
        bottomRight: Radius.circular(props.cornerRadii![2]),
        bottomLeft: Radius.circular(props.cornerRadii![3]),
      );
    } else {
      rrect = RRect.fromRectAndRadius(
        rect,
        Radius.circular(props.effectiveCornerRadius),
      );
    }

    // Draw fills
    for (final fill in props.fills) {
      if (fill['visible'] == false) continue;

      final paint = Paint();
      final fillType = fill['type'];

      if (fillType == 'SOLID') {
        final color = fill['color'];
        if (color is Map) {
          paint.color = Color.fromRGBO(
            ((color['r'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
            ((color['g'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
            ((color['b'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
            (color['a'] as num?)?.toDouble() ?? 1.0,
          );
        }
        canvas.drawRRect(rrect, paint);
      }
    }

    // Draw strokes
    if (props.strokes.isNotEmpty && props.strokeWeight > 0) {
      final stroke = props.strokes.first;
      if (stroke['visible'] != false) {
        final paint = Paint()
          ..style = PaintingStyle.stroke
          ..strokeWidth = props.strokeWeight;

        final color = stroke['color'];
        if (color is Map) {
          paint.color = Color.fromRGBO(
            ((color['r'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
            ((color['g'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
            ((color['b'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
            (color['a'] as num?)?.toDouble() ?? 1.0,
          );
        }
        canvas.drawRRect(rrect, paint);
      }
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

/// Ellipse renderer
class FigmaEllipseWidget extends StatelessWidget {
  final FigmaNodeProperties props;

  const FigmaEllipseWidget({super.key, required this.props});

  @override
  Widget build(BuildContext context) {
    return CustomPaint(
      size: Size(props.width, props.height),
      painter: _EllipsePainter(props: props),
    );
  }
}

class _EllipsePainter extends CustomPainter {
  final FigmaNodeProperties props;

  _EllipsePainter({required this.props});

  @override
  void paint(Canvas canvas, Size size) {
    final rect = Rect.fromLTWH(0, 0, size.width, size.height);

    // Draw fills
    for (final fill in props.fills) {
      if (fill['visible'] == false) continue;

      final paint = Paint();
      final fillType = fill['type'];

      if (fillType == 'SOLID') {
        final color = fill['color'];
        if (color is Map) {
          paint.color = Color.fromRGBO(
            ((color['r'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
            ((color['g'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
            ((color['b'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
            (color['a'] as num?)?.toDouble() ?? 1.0,
          );
        }
        canvas.drawOval(rect, paint);
      }
    }

    // Draw strokes
    if (props.strokes.isNotEmpty && props.strokeWeight > 0) {
      final stroke = props.strokes.first;
      if (stroke['visible'] != false) {
        final paint = Paint()
          ..style = PaintingStyle.stroke
          ..strokeWidth = props.strokeWeight;

        final color = stroke['color'];
        if (color is Map) {
          paint.color = Color.fromRGBO(
            ((color['r'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
            ((color['g'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
            ((color['b'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
            (color['a'] as num?)?.toDouble() ?? 1.0,
          );
        }
        canvas.drawOval(rect, paint);
      }
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

/// Text renderer
class FigmaTextWidget extends StatelessWidget {
  final FigmaNodeProperties props;
  final double scale;
  /// The effective node data (with overrides applied)
  final Map<String, dynamic>? effectiveNode;

  const FigmaTextWidget({super.key, required this.props, this.scale = 1.0, this.effectiveNode});

  @override
  Widget build(BuildContext context) {
    // Use effectiveNode if provided (has overrides), otherwise use props.raw
    final nodeData = effectiveNode ?? props.raw;

    // Extract text content
    final textData = nodeData['textData'];
    String text = '';
    if (textData is Map) {
      text = textData['characters'] as String? ?? '';
    } else {
      text = nodeData['characters'] as String? ?? props.name ?? '';
    }

    // Extract text style with scaling
    var style = _buildTextStyle(text);

    // Get text alignment
    final textAlignHorizontal = props.raw['textAlignHorizontal'] as String?;
    TextAlign textAlign = TextAlign.left;
    if (textAlignHorizontal == 'CENTER') {
      textAlign = TextAlign.center;
    } else if (textAlignHorizontal == 'RIGHT') {
      textAlign = TextAlign.right;
    } else if (textAlignHorizontal == 'JUSTIFIED') {
      textAlign = TextAlign.justify;
    }

    // Check how text should auto-resize
    final textAutoResize = props.raw['textAutoResize'] as String?;
    // HEIGHT = fixed width, height adjusts to content
    // WIDTH_AND_HEIGHT = both adjust to content (no constraints)
    // NONE/TRUNCATE = fixed size

    // For auto-sizing text boxes, don't constrain
    final bool autoWidth = textAutoResize == 'WIDTH_AND_HEIGHT';
    final bool autoHeight = textAutoResize == 'WIDTH_AND_HEIGHT' || textAutoResize == 'HEIGHT';

    return SizedBox(
      width: autoWidth ? null : (props.width > 0 ? props.width * scale : null),
      height: autoHeight ? null : (props.height > 0 ? props.height * scale : null),
      child: Text(
        text,
        style: style,
        textAlign: textAlign,
        overflow: TextOverflow.visible, // Allow overflow to be visible
        softWrap: true,
      ),
    );
  }

  TextStyle _buildTextStyle(String text) {
    double fontSize = 14;
    FontWeight fontWeight = FontWeight.normal;
    FontStyle fontStyle = FontStyle.normal;
    Color color = Colors.black;
    String? fontFamily;
    double? letterSpacing;
    double? height;

    // Check if text contains SF Symbols - if so, force system font
    final bool hasSFSymbols = _containsSFSymbols(text);

    // Try to get font info from various fields
    final fontMetaData = props.raw['fontMetaData'];
    if (fontMetaData is Map && fontMetaData.isNotEmpty) {
      final firstMeta = fontMetaData.values.first;
      if (firstMeta is Map) {
        fontFamily = firstMeta['family'] as String?;
        // Check style for italic
        final style = firstMeta['style'] as String?;
        if (style != null && style.toLowerCase().contains('italic')) {
          fontStyle = FontStyle.italic;
        }
        // Extract weight from style name
        if (style != null) {
          fontWeight = _getFontWeightFromStyle(style);
        }
      }
    }

    // Try fontName field (Figma plugin API format)
    final fontName = props.raw['fontName'];
    if (fontName is Map) {
      fontFamily ??= fontName['family'] as String?;
      final style = fontName['style'] as String?;
      if (style != null) {
        if (style.toLowerCase().contains('italic')) {
          fontStyle = FontStyle.italic;
        }
        fontWeight = _getFontWeightFromStyle(style);
      }
    }

    // Map Figma fonts to system fonts
    fontFamily = _mapFigmaFont(fontFamily);

    // Get font size from derivedTextData or fontSize field
    final derivedTextData = props.raw['derivedTextData'];
    if (derivedTextData is Map) {
      final baseFontSize = derivedTextData['baseFontSize'];
      if (baseFontSize is num) {
        fontSize = baseFontSize.toDouble();
      }
    }

    final rawFontSize = props.raw['fontSize'];
    if (rawFontSize is num) {
      fontSize = rawFontSize.toDouble();
    }

    // Get font weight (explicit field overrides style-derived weight)
    final rawFontWeight = props.raw['fontWeight'];
    if (rawFontWeight is num) {
      fontWeight = _getFontWeight(rawFontWeight.toInt());
    }

    // Get color from fills
    if (props.fills.isNotEmpty) {
      final fill = props.fills.first;
      if (fill['visible'] != false && fill['type'] == 'SOLID') {
        final fillColor = fill['color'];
        if (fillColor is Map) {
          color = Color.fromRGBO(
            ((fillColor['r'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
            ((fillColor['g'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
            ((fillColor['b'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
            (fillColor['a'] as num?)?.toDouble() ?? 1.0,
          );
        }
      }
    }

    // Get letter spacing
    final rawLetterSpacing = props.raw['letterSpacing'];
    if (rawLetterSpacing is num) {
      letterSpacing = rawLetterSpacing.toDouble();
    }

    // Get line height
    final rawLineHeight = props.raw['lineHeight'];
    if (rawLineHeight is num && fontSize > 0) {
      height = rawLineHeight.toDouble() / fontSize;
    }

    // Force system font for SF Symbols (icons)
    if (hasSFSymbols) {
      fontFamily = '.AppleSystemUIFont';
    }

    return TextStyle(
      fontSize: fontSize * scale,
      fontWeight: fontWeight,
      fontStyle: fontStyle,
      color: color,
      fontFamily: fontFamily,
      letterSpacing: letterSpacing != null ? letterSpacing * scale : null,
      height: height,
    );
  }

  FontWeight _getFontWeight(int weight) {
    if (weight <= 100) return FontWeight.w100;
    if (weight <= 200) return FontWeight.w200;
    if (weight <= 300) return FontWeight.w300;
    if (weight <= 400) return FontWeight.w400;
    if (weight <= 500) return FontWeight.w500;
    if (weight <= 600) return FontWeight.w600;
    if (weight <= 700) return FontWeight.w700;
    if (weight <= 800) return FontWeight.w800;
    return FontWeight.w900;
  }

  FontWeight _getFontWeightFromStyle(String style) {
    final lower = style.toLowerCase();
    if (lower.contains('thin') || lower.contains('hairline')) return FontWeight.w100;
    if (lower.contains('extralight') || lower.contains('ultralight')) return FontWeight.w200;
    if (lower.contains('light')) return FontWeight.w300;
    if (lower.contains('regular') || lower.contains('normal')) return FontWeight.w400;
    if (lower.contains('medium')) return FontWeight.w500;
    if (lower.contains('semibold') || lower.contains('demibold')) return FontWeight.w600;
    if (lower.contains('bold') && !lower.contains('extra') && !lower.contains('ultra')) return FontWeight.w700;
    if (lower.contains('extrabold') || lower.contains('ultrabold')) return FontWeight.w800;
    if (lower.contains('black') || lower.contains('heavy')) return FontWeight.w900;
    return FontWeight.w400;
  }

  /// Map Figma font families to system fonts available on macOS/iOS
  String? _mapFigmaFont(String? figmaFont) {
    if (figmaFont == null) return null;

    // Common Figma font mappings to system fonts
    const fontMap = {
      // SF Pro is the default iOS/macOS system font
      'SF Pro': '.AppleSystemUIFont',
      'SF Pro Display': '.AppleSystemUIFont',
      'SF Pro Text': '.AppleSystemUIFont',
      'SF Pro Rounded': '.AppleSystemUIFont',
      'SF Compact': '.AppleSystemUIFont',
      'SF Compact Text': '.AppleSystemUIFont',
      'SF Compact Display': '.AppleSystemUIFont',
      'SF Compact Rounded': '.AppleSystemUIFont',
      'SF Mono': 'Menlo',
      // SF Symbols - used for Apple icons (private use area characters)
      // These characters (like ô€„«) require the SF Pro font with symbols
      'SF Symbols': '.AppleSystemUIFont', // SF Symbols are in the system font
      // Inter is Figma's default font
      'Inter': null, // Let Flutter use default
      // Other common fonts
      'Roboto': 'Roboto',
      'Helvetica': 'Helvetica',
      'Helvetica Neue': 'Helvetica Neue',
      'Arial': 'Arial',
      'Georgia': 'Georgia',
      'Times New Roman': 'Times New Roman',
      'Courier New': 'Courier New',
      'Menlo': 'Menlo',
      'Monaco': 'Monaco',
    };

    // Check direct mapping
    if (fontMap.containsKey(figmaFont)) {
      return fontMap[figmaFont];
    }

    // Check if it starts with a known prefix
    for (final entry in fontMap.entries) {
      if (figmaFont.startsWith(entry.key)) {
        return entry.value;
      }
    }

    // Return original if no mapping found - Flutter will try to use it
    return figmaFont;
  }

  /// Check if text contains SF Symbols (private use area characters)
  bool _containsSFSymbols(String text) {
    // SF Symbols use Unicode Private Use Area: U+100000 to U+10FFFF
    // In Dart, these are represented as surrogate pairs
    for (int i = 0; i < text.length; i++) {
      final code = text.codeUnitAt(i);
      // High surrogate for supplementary planes (U+10000+)
      if (code >= 0xD800 && code <= 0xDBFF) {
        return true;
      }
    }
    return false;
  }
}

/// Vector/path renderer
class FigmaVectorWidget extends StatelessWidget {
  final FigmaNodeProperties props;

  const FigmaVectorWidget({super.key, required this.props});

  @override
  Widget build(BuildContext context) {
    return CustomPaint(
      size: Size(props.width, props.height),
      painter: _VectorPainter(props: props),
    );
  }
}

class _VectorPainter extends CustomPainter {
  final FigmaNodeProperties props;

  _VectorPainter({required this.props});

  @override
  void paint(Canvas canvas, Size size) {
    // Get vector paths from fillGeometry
    final fillGeometry = props.raw['fillGeometry'];
    final strokeGeometry = props.raw['strokeGeometry'];

    // Draw fills
    if (fillGeometry is List) {
      for (final geom in fillGeometry) {
        if (geom is Map) {
          final pathData = geom['path'] as String?;
          if (pathData != null) {
            final path = _parseSvgPath(pathData, size);

            for (final fill in props.fills) {
              if (fill['visible'] == false) continue;

              final paint = Paint();
              if (fill['type'] == 'SOLID') {
                final color = fill['color'];
                if (color is Map) {
                  paint.color = Color.fromRGBO(
                    ((color['r'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
                    ((color['g'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
                    ((color['b'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
                    (color['a'] as num?)?.toDouble() ?? 1.0,
                  );
                  canvas.drawPath(path, paint);
                }
              }
            }
          }
        }
      }
    }

    // Draw strokes
    if (strokeGeometry is List && props.strokeWeight > 0) {
      for (final geom in strokeGeometry) {
        if (geom is Map) {
          final pathData = geom['path'] as String?;
          if (pathData != null) {
            final path = _parseSvgPath(pathData, size);

            for (final stroke in props.strokes) {
              if (stroke['visible'] == false) continue;

              final paint = Paint()
                ..style = PaintingStyle.stroke
                ..strokeWidth = props.strokeWeight;

              final color = stroke['color'];
              if (color is Map) {
                paint.color = Color.fromRGBO(
                  ((color['r'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
                  ((color['g'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
                  ((color['b'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
                  (color['a'] as num?)?.toDouble() ?? 1.0,
                );
                canvas.drawPath(path, paint);
              }
            }
          }
        }
      }
    }

    // Fallback: draw simple shape if no geometry
    if (fillGeometry == null && strokeGeometry == null) {
      final rect = Rect.fromLTWH(0, 0, size.width, size.height);

      for (final fill in props.fills) {
        if (fill['visible'] == false) continue;

        final paint = Paint();
        if (fill['type'] == 'SOLID') {
          final color = fill['color'];
          if (color is Map) {
            paint.color = Color.fromRGBO(
              ((color['r'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
              ((color['g'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
              ((color['b'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
              (color['a'] as num?)?.toDouble() ?? 1.0,
            );
            canvas.drawRect(rect, paint);
          }
        }
      }
    }
  }

  ui.Path _parseSvgPath(String pathData, Size size) {
    final path = ui.Path();
    // Basic SVG path parser - handles M, L, C, Z commands
    // This is a simplified implementation
    final commands = pathData.split(RegExp(r'(?=[MLCQZmlcqz])'));

    double x = 0, y = 0;

    for (var cmd in commands) {
      cmd = cmd.trim();
      if (cmd.isEmpty) continue;

      final type = cmd[0];
      final args = cmd.substring(1).trim().split(RegExp(r'[\s,]+')).where((s) => s.isNotEmpty).map((s) => double.tryParse(s) ?? 0).toList();

      switch (type) {
        case 'M':
          if (args.length >= 2) {
            x = args[0];
            y = args[1];
            path.moveTo(x, y);
          }
          break;
        case 'm':
          if (args.length >= 2) {
            x += args[0];
            y += args[1];
            path.moveTo(x, y);
          }
          break;
        case 'L':
          if (args.length >= 2) {
            x = args[0];
            y = args[1];
            path.lineTo(x, y);
          }
          break;
        case 'l':
          if (args.length >= 2) {
            x += args[0];
            y += args[1];
            path.lineTo(x, y);
          }
          break;
        case 'C':
          if (args.length >= 6) {
            path.cubicTo(args[0], args[1], args[2], args[3], args[4], args[5]);
            x = args[4];
            y = args[5];
          }
          break;
        case 'c':
          if (args.length >= 6) {
            path.cubicTo(x + args[0], y + args[1], x + args[2], y + args[3], x + args[4], y + args[5]);
            x += args[4];
            y += args[5];
          }
          break;
        case 'Q':
          if (args.length >= 4) {
            path.quadraticBezierTo(args[0], args[1], args[2], args[3]);
            x = args[2];
            y = args[3];
          }
          break;
        case 'q':
          if (args.length >= 4) {
            path.quadraticBezierTo(x + args[0], y + args[1], x + args[2], y + args[3]);
            x += args[2];
            y += args[3];
          }
          break;
        case 'Z':
        case 'z':
          path.close();
          break;
      }
    }

    return path;
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

/// Canvas (page) renderer
class FigmaCanvasWidget extends StatelessWidget {
  final FigmaNodeProperties props;
  final Map<String, Map<String, dynamic>>? nodeMap;
  final Map<String, List<int>>? blobMap;
  final String? imagesDirectory;
  final double scale;

  const FigmaCanvasWidget({
    super.key,
    required this.props,
    this.nodeMap,
    this.blobMap,
    this.imagesDirectory,
    this.scale = 1.0,
  });

  @override
  Widget build(BuildContext context) {
    // Get background color from canvas
    Color? backgroundColor;
    final bgColor = props.raw['backgroundColor'];
    if (bgColor is Map) {
      backgroundColor = Color.fromRGBO(
        ((bgColor['r'] as num?)?.toDouble() ?? 1) * 255 ~/ 1,
        ((bgColor['g'] as num?)?.toDouble() ?? 1) * 255 ~/ 1,
        ((bgColor['b'] as num?)?.toDouble() ?? 1) * 255 ~/ 1,
        (bgColor['a'] as num?)?.toDouble() ?? 1.0,
      );
    }

    final children = _buildChildren();

    return Container(
      color: backgroundColor ?? Colors.white,
      child: children.isEmpty
          ? null
          : Stack(
              clipBehavior: Clip.none,
              children: children,
            ),
    );
  }

  List<Widget> _buildChildren() {
    if (nodeMap == null) return [];

    final childrenKeys = props.raw['children'] as List?;
    if (childrenKeys == null) return [];

    final children = <Widget>[];
    // Reverse order: Figma's first child = top, Flutter Stack's last = top
    final reversedKeys = childrenKeys.reversed.toList();
    for (final childKey in reversedKeys) {
      // childKey is now a String key like "0:123"
      final childNode = nodeMap![childKey.toString()];
      if (childNode != null) {
        final childProps = FigmaNodeProperties.fromMap(childNode);
        // Only render visible children
        if (!childProps.visible) continue;

        children.add(
          Positioned(
            left: childProps.x * scale,
            top: childProps.y * scale,
            child: FigmaNodeWidget(
              node: childNode,
              nodeMap: nodeMap,
              blobMap: blobMap,
              imagesDirectory: imagesDirectory,
              scale: scale,
            ),
          ),
        );
      }
    }
    return children;
  }
}

/// Placeholder for unknown node types
class FigmaPlaceholderWidget extends StatelessWidget {
  final FigmaNodeProperties props;

  const FigmaPlaceholderWidget({super.key, required this.props});

  @override
  Widget build(BuildContext context) {
    return Container(
      width: props.width,
      height: props.height,
      decoration: BoxDecoration(
        border: Border.all(color: const Color(0x80808080)), // grey with 0.5 opacity
        color: const Color(0x1A808080), // grey with 0.1 opacity
      ),
      child: Center(
        child: Text(
          props.type,
          style: TextStyle(
            fontSize: 10,
            color: Colors.grey[600],
          ),
        ),
      ),
    );
  }
}

// =============================================================================
// DEBUG OVERLAY SYSTEM
// =============================================================================

/// Global debug overlay controller - manages node inspection state
class DebugOverlayController extends ChangeNotifier {
  static final DebugOverlayController _instance = DebugOverlayController._();
  static DebugOverlayController get instance => _instance;

  DebugOverlayController._();

  bool _enabled = true; // Enabled by default for selection to work
  Map<String, dynamic>? _selectedNode;
  FigmaNodeProperties? _selectedProps;
  String? _hoveredNodeId;
  final List<String> _nodeHistory = [];
  int _historyIndex = -1;

  // For double-click to enter groups
  String? _enteredGroupId; // The group we've "entered" via double-click
  final List<String> _groupStack = []; // Stack of entered groups for nested navigation

  bool get enabled => _enabled;
  Map<String, dynamic>? get selectedNode => _selectedNode;
  FigmaNodeProperties? get selectedProps => _selectedProps;
  String? get hoveredNodeId => _hoveredNodeId;
  String? get enteredGroupId => _enteredGroupId;
  bool get isInsideGroup => _enteredGroupId != null;
  bool get canGoBack => _historyIndex > 0;
  bool get canGoForward => _historyIndex < _nodeHistory.length - 1;

  void toggle() {
    _enabled = !_enabled;
    if (!_enabled) {
      _selectedNode = null;
      _selectedProps = null;
      _hoveredNodeId = null;
    }
    notifyListeners();
  }

  void setEnabled(bool value) {
    if (_enabled != value) {
      _enabled = value;
      if (!_enabled) {
        _selectedNode = null;
        _selectedProps = null;
        _hoveredNodeId = null;
      }
      notifyListeners();
    }
  }

  void selectNode(Map<String, dynamic> node) {
    _selectedNode = node;
    _selectedProps = FigmaNodeProperties.fromMap(node);

    // Add to history
    final nodeId = node['_guidKey']?.toString() ?? '';
    if (_historyIndex < _nodeHistory.length - 1) {
      _nodeHistory.removeRange(_historyIndex + 1, _nodeHistory.length);
    }
    _nodeHistory.add(nodeId);
    _historyIndex = _nodeHistory.length - 1;

    notifyListeners();
  }

  void clearSelection() {
    _selectedNode = null;
    _selectedProps = null;
    notifyListeners();
  }

  void setHovered(String? nodeId) {
    if (_hoveredNodeId != nodeId) {
      _hoveredNodeId = nodeId;
      notifyListeners();
    }
  }

  void goBack(Map<String, Map<String, dynamic>> nodeMap) {
    if (canGoBack) {
      _historyIndex--;
      final nodeId = _nodeHistory[_historyIndex];
      final node = nodeMap[nodeId];
      if (node != null) {
        _selectedNode = node;
        _selectedProps = FigmaNodeProperties.fromMap(node);
        notifyListeners();
      }
    }
  }

  void goForward(Map<String, Map<String, dynamic>> nodeMap) {
    if (canGoForward) {
      _historyIndex++;
      final nodeId = _nodeHistory[_historyIndex];
      final node = nodeMap[nodeId];
      if (node != null) {
        _selectedNode = node;
        _selectedProps = FigmaNodeProperties.fromMap(node);
        notifyListeners();
      }
    }
  }

  /// Update node position (for drag-to-move)
  void updateNodePosition(Map<String, dynamic> node, double x, double y) {
    // Update the transform in the node data
    final transform = node['transform'];
    if (transform is Map) {
      transform['m02'] = x;
      transform['m12'] = y;
    } else {
      node['transform'] = {'m02': x, 'm12': y, 'm00': 1.0, 'm11': 1.0};
    }

    // Update selectedProps if this is the selected node
    if (_selectedNode == node) {
      _selectedProps = FigmaNodeProperties.fromMap(node);
    }

    notifyListeners();
  }

  /// Update node size (for resize handles)
  void updateNodeSize(Map<String, dynamic> node, double width, double height) {
    final size = node['size'];
    if (size is Map) {
      size['x'] = width;
      size['y'] = height;
    } else {
      node['size'] = {'x': width, 'y': height};
    }

    if (_selectedNode == node) {
      _selectedProps = FigmaNodeProperties.fromMap(node);
    }

    notifyListeners();
  }

  /// Update a property on the selected node
  void updateNodeProperty(String key, dynamic value) {
    if (_selectedNode != null) {
      _selectedNode![key] = value;
      _selectedProps = FigmaNodeProperties.fromMap(_selectedNode!);
      notifyListeners();
    }
  }

  /// Enter a group (double-click behavior) to select children inside
  void enterGroup(Map<String, dynamic> node) {
    final nodeId = node['_guidKey']?.toString();
    if (nodeId == null) return;

    // Check if this node has children (is a group/frame)
    final children = node['children'] as List?;
    if (children == null || children.isEmpty) return;

    // Push current group to stack if we're already inside one
    if (_enteredGroupId != null) {
      _groupStack.add(_enteredGroupId!);
    }

    _enteredGroupId = nodeId;
    _selectedNode = node;
    _selectedProps = FigmaNodeProperties.fromMap(node);
    notifyListeners();
  }

  /// Exit the current group (go back up one level)
  void exitGroup(Map<String, Map<String, dynamic>> nodeMap) {
    if (_groupStack.isNotEmpty) {
      // Go back to previous group
      _enteredGroupId = _groupStack.removeLast();
      final node = nodeMap[_enteredGroupId];
      if (node != null) {
        _selectedNode = node;
        _selectedProps = FigmaNodeProperties.fromMap(node);
      }
    } else {
      // Exit to top level
      _enteredGroupId = null;
    }
    notifyListeners();
  }

  /// Exit all groups and go to top level
  void exitAllGroups() {
    _enteredGroupId = null;
    _groupStack.clear();
    notifyListeners();
  }

  /// Check if a node is a direct child of the currently entered group
  bool isDirectChildOfEnteredGroup(Map<String, dynamic> node, Map<String, Map<String, dynamic>> nodeMap) {
    if (_enteredGroupId == null) return true; // At top level, all top-level nodes are valid

    final enteredGroup = nodeMap[_enteredGroupId];
    if (enteredGroup == null) return false;

    final children = enteredGroup['children'] as List?;
    if (children == null) return false;

    final nodeId = node['_guidKey']?.toString();
    return children.any((childKey) => childKey.toString() == nodeId);
  }

  /// Check if a node is the entered group or an ancestor of it
  bool isEnteredGroupOrAncestor(String? nodeId) {
    if (_enteredGroupId == null) return false;
    if (nodeId == _enteredGroupId) return true;
    return _groupStack.contains(nodeId);
  }
}

/// Widget that wraps nodes with debug tap handling and editing
class DebugNodeWrapper extends StatefulWidget {
  final Widget child;
  final Map<String, dynamic> node;
  final double scale;

  const DebugNodeWrapper({
    super.key,
    required this.child,
    required this.node,
    this.scale = 1.0,
  });

  @override
  State<DebugNodeWrapper> createState() => _DebugNodeWrapperState();
}

class _DebugNodeWrapperState extends State<DebugNodeWrapper> {
  Offset? _dragStart;
  Offset? _originalPosition;

  @override
  Widget build(BuildContext context) {
    return ListenableBuilder(
      listenable: DebugOverlayController.instance,
      builder: (context, _) {
        if (!DebugOverlayController.instance.enabled) {
          return widget.child;
        }

        final controller = DebugOverlayController.instance;
        final nodeId = widget.node['_guidKey']?.toString() ?? '';
        final isSelected = controller.selectedNode?['_guidKey'] == nodeId;
        final isHovered = controller.hoveredNodeId == nodeId;
        final props = FigmaNodeProperties.fromMap(widget.node);

        // Check if this node has children (is a group/frame that can be entered)
        final hasChildren = (widget.node['children'] as List?)?.isNotEmpty ?? false;

        return MouseRegion(
          onEnter: (_) => controller.setHovered(nodeId),
          onExit: (_) => controller.setHovered(null),
          cursor: isSelected ? SystemMouseCursors.move : SystemMouseCursors.basic,
          child: GestureDetector(
            onTap: () {
              controller.selectNode(widget.node);
            },
            // Double-click to enter group/frame
            onDoubleTap: hasChildren ? () {
              controller.enterGroup(widget.node);
            } : null,
            // Only enable drag when selected, otherwise let pan/zoom through
            onPanStart: isSelected ? (details) {
              _dragStart = details.localPosition;
              _originalPosition = Offset(props.x, props.y);
            } : null,
            onPanUpdate: isSelected ? (details) {
              if (_dragStart != null && _originalPosition != null) {
                final delta = details.localPosition - _dragStart!;
                final newX = _originalPosition!.dx + delta.dx / widget.scale;
                final newY = _originalPosition!.dy + delta.dy / widget.scale;
                controller.updateNodePosition(widget.node, newX, newY);
              }
            } : null,
            onPanEnd: isSelected ? (details) {
              _dragStart = null;
              _originalPosition = null;
            } : null,
            // Use deferToChild so pan/zoom can work on empty areas
            behavior: HitTestBehavior.deferToChild,
            child: Stack(
              clipBehavior: Clip.none,
              children: [
                widget.child,
                // Selection outline - Figma style
                if (isSelected || isHovered)
                  Positioned.fill(
                    child: IgnorePointer(
                      child: Container(
                        decoration: BoxDecoration(
                          border: Border.all(
                            color: isSelected
                                ? const Color(0xFF0D99FF) // Figma blue
                                : const Color(0x600D99FF),
                            width: isSelected ? 2.0 : 1.0,
                          ),
                        ),
                      ),
                    ),
                  ),
                // Selection handles (corners and edges)
                if (isSelected) ..._buildSelectionHandles(props),
                // Type label on hover
                if (isHovered && !isSelected)
                  Positioned(
                    left: 0,
                    top: -18,
                    child: Container(
                      padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 2),
                      decoration: BoxDecoration(
                        color: const Color(0xFF0D99FF),
                        borderRadius: BorderRadius.circular(2),
                      ),
                      child: Text(
                        '${widget.node['type']}',
                        style: const TextStyle(
                          color: Colors.white,
                          fontSize: 9,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ),
                  ),
                // Size label when selected
                if (isSelected)
                  Positioned(
                    left: 0,
                    bottom: -20,
                    child: Container(
                      padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 2),
                      decoration: BoxDecoration(
                        color: const Color(0xFF0D99FF),
                        borderRadius: BorderRadius.circular(2),
                      ),
                      child: Text(
                        '${props.width.toStringAsFixed(0)} Ã— ${props.height.toStringAsFixed(0)}',
                        style: const TextStyle(
                          color: Colors.white,
                          fontSize: 9,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ),
                  ),
              ],
            ),
          ),
        );
      },
    );
  }

  List<Widget> _buildSelectionHandles(FigmaNodeProperties props) {
    const handleSize = 8.0;
    const handleColor = Color(0xFF0D99FF);

    Widget buildHandle(Alignment alignment, MouseCursor cursor) {
      double? left, right, top, bottom;

      if (alignment.x == -1) left = -handleSize / 2;
      if (alignment.x == 1) right = -handleSize / 2;
      if (alignment.x == 0) left = (props.width * widget.scale - handleSize) / 2;

      if (alignment.y == -1) top = -handleSize / 2;
      if (alignment.y == 1) bottom = -handleSize / 2;
      if (alignment.y == 0) top = (props.height * widget.scale - handleSize) / 2;

      return Positioned(
        left: left,
        right: right,
        top: top,
        bottom: bottom,
        child: MouseRegion(
          cursor: cursor,
          child: Container(
            width: handleSize,
            height: handleSize,
            decoration: BoxDecoration(
              color: Colors.white,
              border: Border.all(color: handleColor, width: 1),
              borderRadius: BorderRadius.circular(1),
            ),
          ),
        ),
      );
    }

    return [
      // Corners
      buildHandle(Alignment.topLeft, SystemMouseCursors.resizeUpLeft),
      buildHandle(Alignment.topRight, SystemMouseCursors.resizeUpRight),
      buildHandle(Alignment.bottomLeft, SystemMouseCursors.resizeDownLeft),
      buildHandle(Alignment.bottomRight, SystemMouseCursors.resizeDownRight),
      // Edges
      buildHandle(Alignment.topCenter, SystemMouseCursors.resizeUp),
      buildHandle(Alignment.bottomCenter, SystemMouseCursors.resizeDown),
      buildHandle(Alignment.centerLeft, SystemMouseCursors.resizeLeft),
      buildHandle(Alignment.centerRight, SystemMouseCursors.resizeRight),
    ];
  }
}

/// Node inspector panel - shows selected node properties
class NodeInspectorPanel extends StatelessWidget {
  final Map<String, Map<String, dynamic>>? nodeMap;

  const NodeInspectorPanel({super.key, this.nodeMap});

  @override
  Widget build(BuildContext context) {
    return ListenableBuilder(
      listenable: DebugOverlayController.instance,
      builder: (context, _) {
        final controller = DebugOverlayController.instance;
        if (!controller.enabled || controller.selectedNode == null) {
          return const SizedBox.shrink();
        }

        final props = controller.selectedProps!;
        final node = controller.selectedNode!;

        return Container(
          width: 320,
          constraints: const BoxConstraints(maxHeight: 500),
          decoration: BoxDecoration(
            color: const Color(0xF5FFFFFF),
            borderRadius: BorderRadius.circular(8),
            boxShadow: const [
              BoxShadow(
                color: Color(0x33000000),
                blurRadius: 12,
                offset: Offset(0, 4),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // Header
              Container(
                padding: const EdgeInsets.all(12),
                decoration: const BoxDecoration(
                  color: Color(0xFF2196F3),
                  borderRadius: BorderRadius.only(
                    topLeft: Radius.circular(8),
                    topRight: Radius.circular(8),
                  ),
                ),
                child: Row(
                  children: [
                    // Navigation buttons
                    if (nodeMap != null) ...[
                      _NavButton(
                        icon: Icons.arrow_back,
                        enabled: controller.canGoBack,
                        onTap: () => controller.goBack(nodeMap!),
                      ),
                      const SizedBox(width: 4),
                      _NavButton(
                        icon: Icons.arrow_forward,
                        enabled: controller.canGoForward,
                        onTap: () => controller.goForward(nodeMap!),
                      ),
                      const SizedBox(width: 8),
                    ],
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            props.name ?? 'Unnamed',
                            style: const TextStyle(
                              color: Colors.white,
                              fontSize: 14,
                              fontWeight: FontWeight.w600,
                            ),
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          ),
                          Text(
                            props.type,
                            style: const TextStyle(
                              color: Color(0xCCFFFFFF),
                              fontSize: 11,
                            ),
                          ),
                        ],
                      ),
                    ),
                    GestureDetector(
                      onTap: () => controller.clearSelection(),
                      child: const Icon(
                        Icons.close,
                        color: Colors.white,
                        size: 20,
                      ),
                    ),
                  ],
                ),
              ),
              // Properties
              Flexible(
                child: SingleChildScrollView(
                  padding: const EdgeInsets.all(12),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      _PropertySection(
                        title: 'Transform',
                        children: [
                          _PropertyRow('Position', '(${props.x.toStringAsFixed(1)}, ${props.y.toStringAsFixed(1)})'),
                          _PropertyRow('Size', '${props.width.toStringAsFixed(1)} x ${props.height.toStringAsFixed(1)}'),
                          if (props.rotation != 0)
                            _PropertyRow('Rotation', '${props.rotation.toStringAsFixed(1)}Â°'),
                        ],
                      ),
                      _PropertySection(
                        title: 'Appearance',
                        children: [
                          _PropertyRow('Opacity', '${(props.opacity * 100).toStringAsFixed(0)}%'),
                          _PropertyRow('Visible', props.visible ? 'Yes' : 'No'),
                          if (props.cornerRadius != null || props.cornerRadii != null)
                            _PropertyRow('Corner Radius', props.cornerRadii?.join(', ') ?? props.cornerRadius?.toStringAsFixed(1) ?? '0'),
                        ],
                      ),
                      if (props.fills.isNotEmpty)
                        _PropertySection(
                          title: 'Fills (${props.fills.length})',
                          children: props.fills.map((fill) {
                            return _FillRow(fill: fill);
                          }).toList(),
                        ),
                      if (props.strokes.isNotEmpty)
                        _PropertySection(
                          title: 'Strokes',
                          children: [
                            _PropertyRow('Weight', '${props.strokeWeight}'),
                            ...props.strokes.map((stroke) => _FillRow(fill: stroke)),
                          ],
                        ),
                      if (props.effects.isNotEmpty)
                        _PropertySection(
                          title: 'Effects (${props.effects.length})',
                          children: props.effects.map((effect) {
                            return _PropertyRow(effect['type']?.toString() ?? 'Unknown', '');
                          }).toList(),
                        ),
                      // Children info
                      if (node['children'] is List)
                        _PropertySection(
                          title: 'Children (${(node['children'] as List).length})',
                          children: [
                            ...(node['children'] as List).take(5).map((childKey) {
                              final child = nodeMap?[childKey.toString()];
                              if (child != null) {
                                return _ChildRow(
                                  name: child['name'] ?? 'Unnamed',
                                  type: child['type'] ?? 'UNKNOWN',
                                  onTap: () => controller.selectNode(child),
                                );
                              }
                              return const SizedBox.shrink();
                            }),
                            if ((node['children'] as List).length > 5)
                              Text(
                                '... and ${(node['children'] as List).length - 5} more',
                                style: TextStyle(
                                  fontSize: 11,
                                  color: Colors.grey[600],
                                  fontStyle: FontStyle.italic,
                                ),
                              ),
                          ],
                        ),
                      // Raw data toggle
                      _ExpandableRawData(node: node),
                    ],
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }
}

class _NavButton extends StatelessWidget {
  final IconData icon;
  final bool enabled;
  final VoidCallback onTap;

  const _NavButton({
    required this.icon,
    required this.enabled,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: enabled ? onTap : null,
      child: Container(
        padding: const EdgeInsets.all(4),
        decoration: BoxDecoration(
          color: enabled ? const Color(0x33FFFFFF) : const Color(0x1AFFFFFF),
          borderRadius: BorderRadius.circular(4),
        ),
        child: Icon(
          icon,
          size: 16,
          color: enabled ? Colors.white : const Color(0x66FFFFFF),
        ),
      ),
    );
  }
}

class _PropertySection extends StatelessWidget {
  final String title;
  final List<Widget> children;

  const _PropertySection({required this.title, required this.children});

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: const TextStyle(
              fontSize: 11,
              fontWeight: FontWeight.w600,
              color: Color(0xFF666666),
            ),
          ),
          const SizedBox(height: 4),
          ...children,
        ],
      ),
    );
  }
}

class _PropertyRow extends StatelessWidget {
  final String label;
  final String value;

  const _PropertyRow(this.label, this.value);

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 100,
            child: Text(
              label,
              style: const TextStyle(fontSize: 12, color: Color(0xFF888888)),
            ),
          ),
          Expanded(
            child: Text(
              value,
              style: const TextStyle(fontSize: 12, fontFamily: 'monospace'),
            ),
          ),
        ],
      ),
    );
  }
}

class _FillRow extends StatelessWidget {
  final Map<String, dynamic> fill;

  const _FillRow({required this.fill});

  @override
  Widget build(BuildContext context) {
    final type = fill['type'] ?? 'UNKNOWN';
    final visible = fill['visible'] ?? true;
    final opacity = (fill['opacity'] as num?)?.toDouble() ?? 1.0;

    String info = type.toString();
    Color? previewColor;

    if (type == 'SOLID') {
      final color = fill['color'];
      if (color is Map) {
        final r = ((color['r'] as num?)?.toDouble() ?? 0) * 255;
        final g = ((color['g'] as num?)?.toDouble() ?? 0) * 255;
        final b = ((color['b'] as num?)?.toDouble() ?? 0) * 255;
        final a = (color['a'] as num?)?.toDouble() ?? 1.0;
        previewColor = Color.fromRGBO(r.toInt(), g.toInt(), b.toInt(), a);
        info = 'rgba(${r.toInt()}, ${g.toInt()}, ${b.toInt()}, ${a.toStringAsFixed(2)})';
      }
    } else if (type == 'IMAGE') {
      final imageRef = fill['image'];
      if (imageRef is Map && imageRef['hash'] is List) {
        final hash = imageHashToHex(imageRef['hash']);
        info = 'IMAGE: ${hash.substring(0, 8)}...';
      }
    } else if (type == 'GRADIENT_LINEAR' || type == 'GRADIENT_RADIAL') {
      info = type.toString().replaceAll('GRADIENT_', '');
    }

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2),
      child: Row(
        children: [
          if (previewColor != null)
            Container(
              width: 16,
              height: 16,
              margin: const EdgeInsets.only(right: 8),
              decoration: BoxDecoration(
                color: previewColor,
                border: Border.all(color: const Color(0x33000000)),
                borderRadius: BorderRadius.circular(2),
              ),
            ),
          Expanded(
            child: Text(
              info,
              style: TextStyle(
                fontSize: 11,
                color: visible ? Colors.black87 : Colors.grey,
                decoration: visible ? null : TextDecoration.lineThrough,
              ),
            ),
          ),
          if (opacity < 1.0)
            Text(
              '${(opacity * 100).toInt()}%',
              style: const TextStyle(fontSize: 10, color: Color(0xFF888888)),
            ),
        ],
      ),
    );
  }
}

class _ChildRow extends StatelessWidget {
  final String name;
  final String type;
  final VoidCallback onTap;

  const _ChildRow({
    required this.name,
    required this.type,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: onTap,
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 3),
        child: Row(
          children: [
            const Icon(Icons.subdirectory_arrow_right, size: 14, color: Color(0xFF888888)),
            const SizedBox(width: 4),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 1),
              decoration: BoxDecoration(
                color: const Color(0xFFE3F2FD),
                borderRadius: BorderRadius.circular(2),
              ),
              child: Text(
                type,
                style: const TextStyle(fontSize: 9, color: Color(0xFF1976D2)),
              ),
            ),
            const SizedBox(width: 6),
            Expanded(
              child: Text(
                name,
                style: const TextStyle(fontSize: 11, color: Color(0xFF2196F3)),
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _ExpandableRawData extends StatefulWidget {
  final Map<String, dynamic> node;

  const _ExpandableRawData({required this.node});

  @override
  State<_ExpandableRawData> createState() => _ExpandableRawDataState();
}

class _ExpandableRawDataState extends State<_ExpandableRawData> {
  bool _expanded = false;

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        InkWell(
          onTap: () => setState(() => _expanded = !_expanded),
          child: Padding(
            padding: const EdgeInsets.symmetric(vertical: 4),
            child: Row(
              children: [
                Icon(
                  _expanded ? Icons.expand_less : Icons.expand_more,
                  size: 16,
                  color: Colors.grey[600],
                ),
                const SizedBox(width: 4),
                Text(
                  'Raw Data (${widget.node.keys.length} keys)',
                  style: TextStyle(
                    fontSize: 11,
                    fontWeight: FontWeight.w600,
                    color: Colors.grey[600],
                  ),
                ),
              ],
            ),
          ),
        ),
        if (_expanded)
          Container(
            padding: const EdgeInsets.all(8),
            decoration: BoxDecoration(
              color: const Color(0xFFF5F5F5),
              borderRadius: BorderRadius.circular(4),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: widget.node.entries.take(30).map((entry) {
                String valueStr;
                if (entry.value is Map) {
                  valueStr = '{...}';
                } else if (entry.value is List) {
                  valueStr = '[${(entry.value as List).length} items]';
                } else {
                  valueStr = entry.value.toString();
                  if (valueStr.length > 50) {
                    valueStr = '${valueStr.substring(0, 50)}...';
                  }
                }
                return Padding(
                  padding: const EdgeInsets.symmetric(vertical: 1),
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        '${entry.key}: ',
                        style: const TextStyle(
                          fontSize: 10,
                          color: Color(0xFF666666),
                          fontFamily: 'monospace',
                        ),
                      ),
                      Expanded(
                        child: Text(
                          valueStr,
                          style: const TextStyle(
                            fontSize: 10,
                            fontFamily: 'monospace',
                          ),
                        ),
                      ),
                    ],
                  ),
                );
              }).toList(),
            ),
          ),
      ],
    );
  }
}

/// Debug toggle button for the canvas
class DebugToggleButton extends StatelessWidget {
  const DebugToggleButton({super.key});

  @override
  Widget build(BuildContext context) {
    return ListenableBuilder(
      listenable: DebugOverlayController.instance,
      builder: (context, _) {
        final isEnabled = DebugOverlayController.instance.enabled;
        return Container(
          decoration: BoxDecoration(
            color: isEnabled ? const Color(0xFF2196F3) : Colors.white,
            borderRadius: BorderRadius.circular(4),
            boxShadow: const [
              BoxShadow(
                color: Color(0x1A000000),
                blurRadius: 4,
              ),
            ],
          ),
          child: Material(
            color: Colors.transparent,
            child: InkWell(
              onTap: () => DebugOverlayController.instance.toggle(),
              borderRadius: BorderRadius.circular(4),
              child: Padding(
                padding: const EdgeInsets.all(8),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      Icons.bug_report,
                      size: 20,
                      color: isEnabled ? Colors.white : Colors.black87,
                    ),
                    const SizedBox(width: 4),
                    Text(
                      'Inspect',
                      style: TextStyle(
                        fontSize: 12,
                        fontWeight: FontWeight.w500,
                        color: isEnabled ? Colors.white : Colors.black87,
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}

/// Figma canvas view with pan, zoom, and page navigation
///
/// This provides a complete canvas experience for viewing Figma documents.

import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/services.dart';
import 'node_renderer.dart';

// Figma's exact colors
class FigmaColors {
  static const bg1 = Color(0xFF1E1E1E);      // Main background
  static const bg2 = Color(0xFF2C2C2C);      // Panels background
  static const bg3 = Color(0xFF383838);      // Hover states
  static const border = Color(0xFF444444);   // Borders
  static const text1 = Color(0xFFFFFFFF);    // Primary text
  static const text2 = Color(0xFFB3B3B3);    // Secondary text
  static const text3 = Color(0xFF7A7A7A);    // Tertiary text
  static const accent = Color(0xFF0D99FF);   // Selection blue
  static const canvas = Color(0xFF252525);   // Canvas background
}

/// Helper class to process Figma message data
class FigmaDocument {
  final Map<String, dynamic> message;
  final Map<String, Map<String, dynamic>> nodeMap;
  final List<Map<String, dynamic>> pages;
  final Map<String, dynamic>? documentNode;
  final Map<String, List<int>> blobMap;
  String? imagesDirectory;

  FigmaDocument._({
    required this.message,
    required this.nodeMap,
    required this.pages,
    this.documentNode,
    required this.blobMap,
    this.imagesDirectory,
  });

  static String _guidToKey(dynamic guid) {
    if (guid is Map) {
      final sessionId = guid['sessionID'] ?? 0;
      final localId = guid['localID'] ?? 0;
      return '$sessionId:$localId';
    }
    return guid.toString();
  }

  factory FigmaDocument.fromMessage(Map<String, dynamic> message) {
    final nodeChanges = message['nodeChanges'] as List? ?? [];
    final nodeMap = <String, Map<String, dynamic>>{};
    final pages = <Map<String, dynamic>>[];
    Map<String, dynamic>? documentNode;

    for (final node in nodeChanges) {
      if (node is Map<String, dynamic>) {
        final guid = node['guid'];
        if (guid != null) {
          final key = _guidToKey(guid);
          nodeMap[key] = node;
          node['_guidKey'] = key;

          final type = node['type'];
          if (type == 'DOCUMENT') {
            documentNode = node;
          } else if (type == 'CANVAS') {
            pages.add(node);
          }
        }
      }
    }

    final childrenMap = <String, List<String>>{};
    for (final node in nodeMap.values) {
      final parentIndex = node['parentIndex'];
      if (parentIndex is Map) {
        final parentGuid = parentIndex['guid'];
        if (parentGuid != null) {
          final parentKey = _guidToKey(parentGuid);
          childrenMap.putIfAbsent(parentKey, () => []);
          childrenMap[parentKey]!.add(node['_guidKey'] as String);
        }
      }
    }

    for (final entry in childrenMap.entries) {
      final node = nodeMap[entry.key];
      if (node != null) {
        node['children'] = entry.value;
      }
    }

    final blobMap = <String, List<int>>{};
    final blobs = message['blobs'] as List?;
    if (blobs != null) {
      for (final blob in blobs) {
        if (blob is Map) {
          final bytes = blob['bytes'];
          if (bytes is List) {
            final index = blobs.indexOf(blob);
            blobMap['blob_$index'] = bytes.cast<int>();
          }
        }
      }
    }

    return FigmaDocument._(
      message: message,
      nodeMap: nodeMap,
      pages: pages,
      documentNode: documentNode,
      blobMap: blobMap,
    );
  }

  int get nodeCount => nodeMap.length;

  Map<String, int> get nodeTypeCounts {
    final counts = <String, int>{};
    for (final node in nodeMap.values) {
      final type = node['type'] as String? ?? 'UNKNOWN';
      counts[type] = (counts[type] ?? 0) + 1;
    }
    return counts;
  }

  Map<String, dynamic> auditImages() {
    final allHashes = <String>{};
    final foundHashes = <String>{};
    final missingHashes = <String>{};
    final nodesByHash = <String, List<String>>{};

    void extractImageHash(Map fill, String source) {
      final imageRef = fill['image'];
      if (imageRef is Map) {
        final hash = imageRef['hash'];
        if (hash is List) {
          final hexHash = imageHashToHex(hash);
          if (hexHash.isNotEmpty) {
            allHashes.add(hexHash);
            nodesByHash.putIfAbsent(hexHash, () => []);
            nodesByHash[hexHash]!.add(source);
          }
        }
      }
    }

    for (final node in nodeMap.values) {
      final nodeName = node['name'] as String? ?? 'unnamed';
      final fillPaints = node['fillPaints'] as List? ?? [];

      for (final fill in fillPaints) {
        if (fill is Map && fill['type'] == 'IMAGE') {
          extractImageHash(fill, nodeName);
        }
      }

      final symbolData = node['symbolData'];
      if (symbolData is Map) {
        final overrides = symbolData['symbolOverrides'];
        if (overrides is List) {
          for (final override in overrides) {
            if (override is Map) {
              final overrideFills = override['fillPaints'] as List?;
              if (overrideFills != null) {
                for (final fill in overrideFills) {
                  if (fill is Map && fill['type'] == 'IMAGE') {
                    extractImageHash(fill, '$nodeName (override)');
                  }
                }
              }
            }
          }
        }
      }
    }

    if (imagesDirectory != null) {
      for (final hash in allHashes) {
        final file = File('$imagesDirectory/$hash');
        if (file.existsSync()) {
          foundHashes.add(hash);
        } else {
          missingHashes.add(hash);
        }
      }
    }

    print('IMAGE AUDIT:');
    print('  Total unique images: ${allHashes.length}');
    print('  Found: ${foundHashes.length}');
    print('  Missing: ${missingHashes.length}');

    if (missingHashes.isNotEmpty) {
      print('  Missing image hashes:');
      for (final hash in missingHashes.take(10)) {
        final nodes = nodesByHash[hash] ?? [];
        print('    $hash (used by: ${nodes.take(3).join(", ")})');
      }
    }

    return {
      'total': allHashes.length,
      'found': foundHashes.length,
      'missing': missingHashes.length,
      'missingHashes': missingHashes.toList(),
      'foundHashes': foundHashes.toList(),
    };
  }
}

/// Main canvas widget - Figma-like editor
class FigmaCanvasView extends StatefulWidget {
  final FigmaDocument document;
  final int initialPageIndex;
  final bool showPageSelector;
  final bool showDebugInfo;
  final Color backgroundColor;

  const FigmaCanvasView({
    super.key,
    required this.document,
    this.initialPageIndex = 0,
    this.showPageSelector = true,
    this.showDebugInfo = false,
    this.backgroundColor = FigmaColors.canvas,
  });

  @override
  State<FigmaCanvasView> createState() => _FigmaCanvasViewState();
}

class _FigmaCanvasViewState extends State<FigmaCanvasView> {
  late int _currentPageIndex;
  late TransformationController _transformController;
  final ValueNotifier<double> _scaleNotifier = ValueNotifier(1.0);
  double get _scale => _scaleNotifier.value;
  set _scale(double v) => _scaleNotifier.value = v;
  bool _showLeftPanel = true;
  bool _showRightPanel = true;
  int _rightPanelTab = 0; // 0=Design, 1=Prototype, 2=Inspect
  int _leftPanelTab = 0; // 0=Layers, 1=Assets

  // Cached canvas content widget
  Widget? _cachedCanvasContent;
  int? _cachedPageIndex;

  @override
  void initState() {
    super.initState();
    _currentPageIndex = widget.initialPageIndex;
    _transformController = TransformationController();
  }

  @override
  void dispose() {
    _transformController.dispose();
    _scaleNotifier.dispose();
    super.dispose();
  }

  Map<String, dynamic>? get _currentPage {
    if (_currentPageIndex < 0 || _currentPageIndex >= widget.document.pages.length) {
      return null;
    }
    return widget.document.pages[_currentPageIndex];
  }

  void _onPageChanged(int index) {
    _cachedCanvasContent = null; // Invalidate cache
    setState(() {
      _currentPageIndex = index;
      _transformController.value = Matrix4.identity();
      _scale = 1.0;
    });
  }

  void _setScale(double newScale, Offset focalPoint) {
    newScale = newScale.clamp(0.02, 25.0);
    final oldScale = _scale;
    final matrix = _transformController.value.clone();
    final translation = matrix.getTranslation();
    final focalPointInCanvas = (focalPoint - Offset(translation.x, translation.y)) / oldScale;
    final newTranslation = focalPoint - focalPointInCanvas * newScale;

    // Update scale without setState - use notifier
    _scale = newScale;
    final newMatrix = Matrix4.identity();
    newMatrix.setEntry(0, 3, newTranslation.dx);
    newMatrix.setEntry(1, 3, newTranslation.dy);
    newMatrix.setEntry(0, 0, newScale);
    newMatrix.setEntry(1, 1, newScale);
    _transformController.value = newMatrix;
  }

  void _zoomToFit() {
    final page = _currentPage;
    if (page == null) return;

    final children = page['children'] as List?;
    if (children == null || children.isEmpty) return;

    double minX = double.infinity, minY = double.infinity;
    double maxX = double.negativeInfinity, maxY = double.negativeInfinity;

    for (final childId in children) {
      final child = widget.document.nodeMap[childId.toString()];
      if (child != null) {
        final props = FigmaNodeProperties.fromMap(child);
        minX = minX < props.x ? minX : props.x;
        minY = minY < props.y ? minY : props.y;
        maxX = maxX > (props.x + props.width) ? maxX : (props.x + props.width);
        maxY = maxY > (props.y + props.height) ? maxY : (props.y + props.height);
      }
    }

    if (minX == double.infinity) return;

    final contentWidth = maxX - minX;
    final contentHeight = maxY - minY;
    final screenSize = MediaQuery.of(context).size;
    final availableWidth = screenSize.width - (_showLeftPanel ? 240 : 0) - (_showRightPanel ? 300 : 0);
    final availableHeight = screenSize.height - 88;
    final padding = 100.0;

    final scaleX = (availableWidth - padding) / contentWidth;
    final scaleY = (availableHeight - padding) / contentHeight;
    final newScale = (scaleX < scaleY ? scaleX : scaleY).clamp(0.02, 1.0);

    final centerX = (minX + maxX) / 2;
    final centerY = (minY + maxY) / 2;
    final offsetX = availableWidth / 2 - centerX * newScale + (_showLeftPanel ? 240 : 0);
    final offsetY = availableHeight / 2 - centerY * newScale + 48;

    // Update scale without setState
    _scale = newScale;
    final matrix = Matrix4.identity();
    matrix.setEntry(0, 3, offsetX);
    matrix.setEntry(1, 3, offsetY);
    matrix.setEntry(0, 0, newScale);
    matrix.setEntry(1, 1, newScale);
    _transformController.value = matrix;
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: FigmaColors.bg1,
      body: Column(
        children: [
          _buildToolbar(),
          Expanded(
            child: Row(
              children: [
                if (_showLeftPanel) _buildLeftPanel(),
                Expanded(child: _buildCanvas()),
                if (_showRightPanel) _buildRightPanel(),
              ],
            ),
          ),
        ],
      ),
    );
  }

  // ============ TOOLBAR ============
  Widget _buildToolbar() {
    return Container(
      height: 48,
      decoration: const BoxDecoration(
        color: FigmaColors.bg2,
        border: Border(bottom: BorderSide(color: FigmaColors.border, width: 1)),
      ),
      child: Row(
        children: [
          // Menu button
          _ToolbarButton(icon: Icons.menu, onTap: () {}),
          Container(width: 1, height: 24, color: FigmaColors.border),

          // Move tool
          _ToolbarButton(icon: Icons.near_me_outlined, onTap: () {}, selected: true),
          _ToolbarButton(icon: Icons.crop_free, onTap: () {}),
          Container(width: 1, height: 24, color: FigmaColors.border),

          // Shape tools
          _ToolbarButton(icon: Icons.rectangle_outlined, onTap: () {}),
          _ToolbarButton(icon: Icons.create_outlined, onTap: () {}),
          _ToolbarButton(icon: Icons.text_fields, onTap: () {}),
          Container(width: 1, height: 24, color: FigmaColors.border),

          // Hand tool
          _ToolbarButton(icon: Icons.pan_tool_outlined, onTap: () {}),
          _ToolbarButton(icon: Icons.chat_bubble_outline, onTap: () {}),

          const Spacer(),

          // File name / page tabs
          _buildPageDropdown(),

          const Spacer(),

          // Right side controls
          _ToolbarButton(
            icon: Icons.play_arrow,
            onTap: () {},
            label: 'Present',
          ),
          const SizedBox(width: 8),
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
            decoration: BoxDecoration(
              color: FigmaColors.accent,
              borderRadius: BorderRadius.circular(6),
            ),
            child: const Text('Share', style: TextStyle(color: Colors.white, fontSize: 12, fontWeight: FontWeight.w500)),
          ),
          const SizedBox(width: 8),
          _ToolbarButton(icon: Icons.more_horiz, onTap: () {}),
          const SizedBox(width: 8),
        ],
      ),
    );
  }

  Widget _buildPageDropdown() {
    final page = _currentPage;
    return PopupMenuButton<int>(
      offset: const Offset(0, 40),
      color: FigmaColors.bg2,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              page?['name'] as String? ?? 'Untitled',
              style: const TextStyle(color: FigmaColors.text1, fontSize: 13),
            ),
            const SizedBox(width: 4),
            const Icon(Icons.keyboard_arrow_down, color: FigmaColors.text2, size: 16),
          ],
        ),
      ),
      itemBuilder: (context) => widget.document.pages.asMap().entries.map((entry) {
        return PopupMenuItem<int>(
          value: entry.key,
          child: Row(
            children: [
              Icon(
                entry.key == _currentPageIndex ? Icons.check : null,
                size: 16,
                color: FigmaColors.text1,
              ),
              const SizedBox(width: 8),
              Text(
                entry.value['name'] as String? ?? 'Page ${entry.key + 1}',
                style: const TextStyle(color: FigmaColors.text1, fontSize: 12),
              ),
            ],
          ),
        );
      }).toList(),
      onSelected: _onPageChanged,
    );
  }

  // ============ LEFT PANEL ============
  Widget _buildLeftPanel() {
    return Container(
      width: 240,
      decoration: const BoxDecoration(
        color: FigmaColors.bg2,
        border: Border(right: BorderSide(color: FigmaColors.border, width: 1)),
      ),
      child: Column(
        children: [
          // Panel header with tabs
          Container(
            height: 40,
            decoration: const BoxDecoration(
              border: Border(bottom: BorderSide(color: FigmaColors.border, width: 1)),
            ),
            child: Row(
              children: [
                _PanelTab(label: 'Layers', selected: _leftPanelTab == 0, onTap: () => setState(() => _leftPanelTab = 0)),
                _PanelTab(label: 'Assets', selected: _leftPanelTab == 1, onTap: () => setState(() => _leftPanelTab = 1)),
              ],
            ),
          ),
          // Content based on tab
          Expanded(child: _leftPanelTab == 0 ? _buildLayersContent() : _buildAssetsContent()),
        ],
      ),
    );
  }

  Widget _buildLayersContent() {
    return Column(
      children: [
        // Page header
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
          decoration: const BoxDecoration(
            border: Border(bottom: BorderSide(color: FigmaColors.border, width: 1)),
          ),
          child: Row(
            children: [
              const Icon(Icons.description_outlined, size: 14, color: FigmaColors.text2),
              const SizedBox(width: 6),
              Expanded(
                child: Text(
                  _currentPage?['name'] as String? ?? 'Page',
                  style: const TextStyle(color: FigmaColors.text1, fontSize: 11),
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ],
          ),
        ),
        // Layer tree
        Expanded(child: _buildLayerTree()),
      ],
    );
  }

  Widget _buildAssetsContent() {
    // Extract components from the document
    final components = <Map<String, dynamic>>[];
    for (final node in widget.document.nodeMap.values) {
      final type = node['type'];
      if (type == 'COMPONENT' || type == 'COMPONENT_SET') {
        components.add(node);
      }
    }

    return Column(
      children: [
        // Search bar
        Container(
          padding: const EdgeInsets.all(8),
          decoration: const BoxDecoration(
            border: Border(bottom: BorderSide(color: FigmaColors.border, width: 1)),
          ),
          child: Container(
            height: 32,
            padding: const EdgeInsets.symmetric(horizontal: 8),
            decoration: BoxDecoration(
              color: FigmaColors.bg1,
              borderRadius: BorderRadius.circular(4),
              border: Border.all(color: FigmaColors.border),
            ),
            child: const Row(
              children: [
                Icon(Icons.search, size: 14, color: FigmaColors.text3),
                SizedBox(width: 8),
                Expanded(
                  child: Text(
                    'Search in this library',
                    style: TextStyle(color: FigmaColors.text3, fontSize: 11),
                  ),
                ),
                Icon(Icons.tune, size: 14, color: FigmaColors.text3),
              ],
            ),
          ),
        ),
        // Section header
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
          child: Row(
            children: [
              const Icon(Icons.chevron_left, size: 14, color: FigmaColors.text2),
              const SizedBox(width: 4),
              const Expanded(
                child: Text(
                  'Created in this file',
                  style: TextStyle(color: FigmaColors.text1, fontSize: 11),
                ),
              ),
            ],
          ),
        ),
        // Components grid
        Expanded(
          child: GridView.builder(
            padding: const EdgeInsets.all(8),
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 2,
              childAspectRatio: 1.0,
              crossAxisSpacing: 8,
              mainAxisSpacing: 8,
            ),
            itemCount: components.length,
            itemBuilder: (context, index) {
              final comp = components[index];
              final name = comp['name'] as String? ?? 'Component';
              return GestureDetector(
                onTap: () {
                  DebugOverlayController.instance.selectNode(comp);
                  _centerOnNode(comp);
                },
                child: Container(
                  decoration: BoxDecoration(
                    color: FigmaColors.bg3,
                    borderRadius: BorderRadius.circular(4),
                  ),
                  child: Column(
                    children: [
                      Expanded(
                        child: Container(
                          decoration: BoxDecoration(
                            color: FigmaColors.bg1,
                            borderRadius: const BorderRadius.vertical(top: Radius.circular(4)),
                          ),
                          child: const Center(
                            child: Icon(Icons.widgets_outlined, size: 24, color: FigmaColors.text3),
                          ),
                        ),
                      ),
                      Container(
                        padding: const EdgeInsets.all(6),
                        child: Text(
                          name,
                          style: const TextStyle(color: FigmaColors.text2, fontSize: 10),
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                        ),
                      ),
                    ],
                  ),
                ),
              );
            },
          ),
        ),
        // Footer showing count
        Container(
          padding: const EdgeInsets.all(8),
          decoration: const BoxDecoration(
            border: Border(top: BorderSide(color: FigmaColors.border, width: 1)),
          ),
          child: Text(
            '${components.length} components',
            style: const TextStyle(color: FigmaColors.text3, fontSize: 10),
          ),
        ),
      ],
    );
  }

  Widget _buildLayerTree() {
    final page = _currentPage;
    if (page == null) return const SizedBox.shrink();

    final children = page['children'] as List? ?? [];

    return _KeyboardNavigableLayerTree(
      children: children,
      nodeMap: widget.document.nodeMap,
      onSelect: (node) {
        DebugOverlayController.instance.setEnabled(true);
        DebugOverlayController.instance.selectNode(node);
        _centerOnNode(node);
      },
    );
  }

  void _centerOnNode(Map<String, dynamic> node) {
    final props = FigmaNodeProperties.fromMap(node);

    // Get the canvas area dimensions
    final screenSize = MediaQuery.of(context).size;
    final canvasWidth = screenSize.width - (_showLeftPanel ? 240 : 0) - (_showRightPanel ? 300 : 0);
    final canvasHeight = screenSize.height - 88; // toolbar + bottom bar

    // Calculate center of the node
    final nodeCenterX = props.x + props.width / 2;
    final nodeCenterY = props.y + props.height / 2;

    // Calculate offset to center the node in the canvas
    final offsetX = canvasWidth / 2 - nodeCenterX * _scale + (_showLeftPanel ? 240 : 0);
    final offsetY = canvasHeight / 2 - nodeCenterY * _scale + 48; // 48 for toolbar

    // Update transform
    final matrix = Matrix4.identity();
    matrix.setEntry(0, 3, offsetX);
    matrix.setEntry(1, 3, offsetY);
    matrix.setEntry(0, 0, _scale);
    matrix.setEntry(1, 1, _scale);
    _transformController.value = matrix;
  }

  // ============ CANVAS ============
  Widget _buildCanvas() {
    return Focus(
      autofocus: true,
      onKeyEvent: (node, event) {
        if (event is KeyDownEvent) {
          // Escape to exit group or clear selection
          if (event.logicalKey == LogicalKeyboardKey.escape) {
            final controller = DebugOverlayController.instance;
            if (controller.isInsideGroup) {
              controller.exitGroup(widget.document.nodeMap);
              return KeyEventResult.handled;
            } else if (controller.selectedNode != null) {
              controller.clearSelection();
              return KeyEventResult.handled;
            }
          }
        }
        return KeyEventResult.ignored;
      },
      child: Container(
        color: FigmaColors.canvas,
        child: Stack(
          children: [
            // Main canvas with RepaintBoundary for performance
            Listener(
            onPointerSignal: (event) {
              if (event is PointerScrollEvent) {
                // Check for pinch zoom (trackpad) vs scroll
                if (HardwareKeyboard.instance.isControlPressed ||
                    HardwareKeyboard.instance.isMetaPressed) {
                  final delta = event.scrollDelta.dy;
                  final factor = delta > 0 ? 0.9 : 1.1;
                  _setScale(_scale * factor, event.localPosition);
                } else {
                  // Pan - just update controller, no setState needed
                  final matrix = _transformController.value.clone();
                  matrix.translate(-event.scrollDelta.dx, -event.scrollDelta.dy);
                  _transformController.value = matrix;
                }
              }
            },
            child: InteractiveViewer(
              transformationController: _transformController,
              minScale: 0.02,
              maxScale: 25.0,
              boundaryMargin: const EdgeInsets.all(double.infinity),
              panEnabled: true,
              scaleEnabled: true,
              onInteractionUpdate: (details) {
                // Just update the notifier, no setState - prevents rebuild
                _scaleNotifier.value = _transformController.value.getMaxScaleOnAxis();
              },
              child: RepaintBoundary(
                child: _buildCanvasContent(),
              ),
            ),
          ),

          // Bottom toolbar
          Positioned(
            left: 0,
            right: 0,
            bottom: 0,
            child: _buildBottomBar(),
          ),
        ],
      ),
      ),
    );
  }

  Widget _buildCanvasContent() {
    final page = _currentPage;
    if (page == null) {
      return const Center(child: Text('No pages found', style: TextStyle(color: FigmaColors.text2)));
    }

    // Cache the content widget to avoid rebuilding on pan/zoom
    if (_cachedCanvasContent != null && _cachedPageIndex == _currentPageIndex) {
      return _cachedCanvasContent!;
    }

    _cachedPageIndex = _currentPageIndex;
    _cachedCanvasContent = SizedBox(
      width: 20000,
      height: 20000,
      child: FigmaNodeWidget(
        node: page,
        nodeMap: widget.document.nodeMap,
        blobMap: widget.document.blobMap,
        imagesDirectory: widget.document.imagesDirectory,
        scale: 1.0,
      ),
    );
    return _cachedCanvasContent!;
  }

  Widget _buildBottomBar() {
    return Container(
      height: 40,
      color: FigmaColors.bg2.withOpacity(0.95),
      padding: const EdgeInsets.symmetric(horizontal: 12),
      child: Row(
        children: [
          // Left side - toggle panels
          _BottomBarButton(
            icon: Icons.view_sidebar_outlined,
            selected: _showLeftPanel,
            onTap: () => setState(() => _showLeftPanel = !_showLeftPanel),
          ),
          const SizedBox(width: 8),

          // Zoom controls
          _BottomBarButton(icon: Icons.remove, onTap: () => _setScale(_scale / 1.2, Offset(MediaQuery.of(context).size.width / 2, MediaQuery.of(context).size.height / 2))),
          Container(
            width: 60,
            alignment: Alignment.center,
            child: GestureDetector(
              onTap: _zoomToFit,
              child: ValueListenableBuilder<double>(
                valueListenable: _scaleNotifier,
                builder: (context, scale, _) => Text(
                  '${(scale * 100).toStringAsFixed(0)}%',
                  style: const TextStyle(color: FigmaColors.text1, fontSize: 11),
                ),
              ),
            ),
          ),
          _BottomBarButton(icon: Icons.add, onTap: () => _setScale(_scale * 1.2, Offset(MediaQuery.of(context).size.width / 2, MediaQuery.of(context).size.height / 2))),

          const Spacer(),

          // Right side
          _BottomBarButton(
            icon: Icons.grid_on,
            onTap: () {},
          ),
          const SizedBox(width: 8),
          _BottomBarButton(
            icon: _showRightPanel ? Icons.view_sidebar : Icons.view_sidebar_outlined,
            selected: _showRightPanel,
            onTap: () => setState(() => _showRightPanel = !_showRightPanel),
          ),
        ],
      ),
    );
  }

  // ============ RIGHT PANEL ============
  Widget _buildRightPanel() {
    return Container(
      width: 300,
      decoration: const BoxDecoration(
        color: FigmaColors.bg2,
        border: Border(left: BorderSide(color: FigmaColors.border, width: 1)),
      ),
      child: Column(
        children: [
          // Tab bar
          Container(
            height: 40,
            decoration: const BoxDecoration(
              border: Border(bottom: BorderSide(color: FigmaColors.border, width: 1)),
            ),
            child: Row(
              children: [
                _PanelTab(label: 'Design', selected: _rightPanelTab == 0, onTap: () => setState(() => _rightPanelTab = 0)),
                _PanelTab(label: 'Prototype', selected: _rightPanelTab == 1, onTap: () => setState(() => _rightPanelTab = 1)),
                _PanelTab(label: 'Inspect', selected: _rightPanelTab == 2, onTap: () => setState(() => _rightPanelTab = 2)),
              ],
            ),
          ),
          // Content
          Expanded(
            child: ListenableBuilder(
              listenable: DebugOverlayController.instance,
              builder: (context, _) {
                final node = DebugOverlayController.instance.selectedNode;
                final props = DebugOverlayController.instance.selectedProps;

                if (node == null) {
                  return const Center(
                    child: Text('Select a layer', style: TextStyle(color: FigmaColors.text3, fontSize: 12)),
                  );
                }

                return _buildDesignPanel(node, props!);
              },
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildDesignPanel(Map<String, dynamic> node, FigmaNodeProperties props) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Alignment section
          _buildAlignmentSection(),
          const _Divider(),

          // Frame/Position section
          _buildFrameSection(props),
          const _Divider(),

          // Layer section
          _buildLayerSection(props),

          // Fill section
          if (props.fills.isNotEmpty) ...[
            const _Divider(),
            _buildFillSection(props),
          ],

          // Stroke section
          if (props.strokes.isNotEmpty) ...[
            const _Divider(),
            _buildStrokeSection(props),
          ],

          // Effects section
          if (props.effects.isNotEmpty) ...[
            const _Divider(),
            _buildEffectsSection(props),
          ],
        ],
      ),
    );
  }

  Widget _buildAlignmentSection() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: [
        _AlignButton(icon: Icons.align_horizontal_left),
        _AlignButton(icon: Icons.align_horizontal_center),
        _AlignButton(icon: Icons.align_horizontal_right),
        Container(width: 1, height: 20, color: FigmaColors.border),
        _AlignButton(icon: Icons.align_vertical_top),
        _AlignButton(icon: Icons.align_vertical_center),
        _AlignButton(icon: Icons.align_vertical_bottom),
      ],
    );
  }

  Widget _buildFrameSection(FigmaNodeProperties props) {
    final controller = DebugOverlayController.instance;
    final node = controller.selectedNode;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Expanded(
              child: _EditableInputField(
                label: 'X',
                value: props.x.toStringAsFixed(0),
                onChanged: (val) {
                  final newX = double.tryParse(val) ?? props.x;
                  if (node != null) controller.updateNodePosition(node, newX, props.y);
                },
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              child: _EditableInputField(
                label: 'Y',
                value: props.y.toStringAsFixed(0),
                onChanged: (val) {
                  final newY = double.tryParse(val) ?? props.y;
                  if (node != null) controller.updateNodePosition(node, props.x, newY);
                },
              ),
            ),
          ],
        ),
        const SizedBox(height: 8),
        Row(
          children: [
            Expanded(
              child: _EditableInputField(
                label: 'W',
                value: props.width.toStringAsFixed(0),
                onChanged: (val) {
                  final newW = double.tryParse(val) ?? props.width;
                  if (node != null) controller.updateNodeSize(node, newW, props.height);
                },
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              child: _EditableInputField(
                label: 'H',
                value: props.height.toStringAsFixed(0),
                onChanged: (val) {
                  final newH = double.tryParse(val) ?? props.height;
                  if (node != null) controller.updateNodeSize(node, props.width, newH);
                },
              ),
            ),
          ],
        ),
        const SizedBox(height: 8),
        Row(
          children: [
            Expanded(child: _InputField(label: 'R', value: props.rotation.toStringAsFixed(0) + 'Â°')),
            const SizedBox(width: 8),
            Expanded(
              child: _InputField(
                label: 'â—°',
                value: props.cornerRadius?.toStringAsFixed(0) ?? '0',
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildLayerSection(FigmaNodeProperties props) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const _SectionHeader(title: 'Layer'),
        const SizedBox(height: 8),
        Row(
          children: [
            const Text('Opacity', style: TextStyle(color: FigmaColors.text2, fontSize: 11)),
            const Spacer(),
            SizedBox(
              width: 50,
              child: Text(
                '${(props.opacity * 100).toStringAsFixed(0)}%',
                style: const TextStyle(color: FigmaColors.text1, fontSize: 11),
                textAlign: TextAlign.right,
              ),
            ),
          ],
        ),
        const SizedBox(height: 4),
        Container(
          height: 2,
          decoration: BoxDecoration(
            color: FigmaColors.bg3,
            borderRadius: BorderRadius.circular(1),
          ),
          child: FractionallySizedBox(
            widthFactor: props.opacity,
            alignment: Alignment.centerLeft,
            child: Container(
              decoration: BoxDecoration(
                color: FigmaColors.text1,
                borderRadius: BorderRadius.circular(1),
              ),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildFillSection(FigmaNodeProperties props) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            const _SectionHeader(title: 'Fill'),
            const Spacer(),
            Icon(Icons.add, size: 14, color: FigmaColors.text2),
          ],
        ),
        const SizedBox(height: 8),
        ...props.fills.map((fill) => _FillItem(fill: fill)),
      ],
    );
  }

  Widget _buildStrokeSection(FigmaNodeProperties props) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const _SectionHeader(title: 'Stroke'),
        const SizedBox(height: 8),
        ...props.strokes.map((stroke) => _FillItem(fill: stroke)),
        const SizedBox(height: 8),
        Row(
          children: [
            const Text('Weight', style: TextStyle(color: FigmaColors.text2, fontSize: 11)),
            const Spacer(),
            Text('${props.strokeWeight}', style: const TextStyle(color: FigmaColors.text1, fontSize: 11)),
          ],
        ),
      ],
    );
  }

  Widget _buildEffectsSection(FigmaNodeProperties props) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const _SectionHeader(title: 'Effects'),
        const SizedBox(height: 8),
        ...props.effects.map((effect) => Container(
          padding: const EdgeInsets.symmetric(vertical: 4),
          child: Row(
            children: [
              const Icon(Icons.blur_on, size: 14, color: FigmaColors.text2),
              const SizedBox(width: 8),
              Text(
                effect['type']?.toString() ?? 'Effect',
                style: const TextStyle(color: FigmaColors.text1, fontSize: 11),
              ),
            ],
          ),
        )),
      ],
    );
  }
}

// ============ HELPER WIDGETS ============

class _ToolbarButton extends StatelessWidget {
  final IconData icon;
  final VoidCallback onTap;
  final bool selected;
  final String? label;

  const _ToolbarButton({required this.icon, required this.onTap, this.selected = false, this.label});

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 8),
        decoration: BoxDecoration(
          color: selected ? FigmaColors.bg3 : Colors.transparent,
          borderRadius: BorderRadius.circular(4),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, size: 18, color: selected ? FigmaColors.text1 : FigmaColors.text2),
            if (label != null) ...[
              const SizedBox(width: 4),
              Text(label!, style: TextStyle(color: selected ? FigmaColors.text1 : FigmaColors.text2, fontSize: 12)),
            ],
          ],
        ),
      ),
    );
  }
}

class _PanelTab extends StatelessWidget {
  final String label;
  final bool selected;
  final VoidCallback onTap;

  const _PanelTab({required this.label, required this.selected, required this.onTap});

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16),
        decoration: BoxDecoration(
          border: Border(
            bottom: BorderSide(
              color: selected ? FigmaColors.accent : Colors.transparent,
              width: 2,
            ),
          ),
        ),
        child: Center(
          child: Text(
            label,
            style: TextStyle(
              color: selected ? FigmaColors.text1 : FigmaColors.text3,
              fontSize: 11,
              fontWeight: selected ? FontWeight.w500 : FontWeight.normal,
            ),
          ),
        ),
      ),
    );
  }
}

class _BottomBarButton extends StatelessWidget {
  final IconData icon;
  final VoidCallback onTap;
  final bool selected;

  const _BottomBarButton({required this.icon, required this.onTap, this.selected = false});

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.all(6),
        decoration: BoxDecoration(
          color: selected ? FigmaColors.bg3 : Colors.transparent,
          borderRadius: BorderRadius.circular(4),
        ),
        child: Icon(icon, size: 16, color: FigmaColors.text2),
      ),
    );
  }
}

/// Keyboard-navigable layer tree with arrow key support
class _KeyboardNavigableLayerTree extends StatefulWidget {
  final List children;
  final Map<String, Map<String, dynamic>> nodeMap;
  final void Function(Map<String, dynamic>) onSelect;

  const _KeyboardNavigableLayerTree({
    required this.children,
    required this.nodeMap,
    required this.onSelect,
  });

  @override
  State<_KeyboardNavigableLayerTree> createState() => _KeyboardNavigableLayerTreeState();
}

class _KeyboardNavigableLayerTreeState extends State<_KeyboardNavigableLayerTree> {
  final FocusNode _focusNode = FocusNode();
  final Set<String> _expandedNodes = {};
  int _focusedIndex = 0;
  List<_FlatLayerItem> _flatList = [];
  final ScrollController _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    _rebuildFlatList();
  }

  @override
  void dispose() {
    _focusNode.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  void _rebuildFlatList() {
    _flatList = [];
    for (final childKey in widget.children) {
      _addToFlatList(childKey.toString(), 0);
    }
  }

  void _addToFlatList(String key, int depth) {
    final node = widget.nodeMap[key];
    if (node == null) return;

    final children = node['children'] as List? ?? [];
    final hasChildren = children.isNotEmpty;
    final isExpanded = _expandedNodes.contains(key);

    _flatList.add(_FlatLayerItem(
      key: key,
      node: node,
      depth: depth,
      hasChildren: hasChildren,
      isExpanded: isExpanded,
    ));

    if (isExpanded && hasChildren) {
      for (final childKey in children) {
        _addToFlatList(childKey.toString(), depth + 1);
      }
    }
  }

  void _handleKeyEvent(KeyEvent event) {
    if (event is! KeyDownEvent) return;

    final key = event.logicalKey;

    if (key == LogicalKeyboardKey.arrowUp) {
      _moveFocus(-1);
    } else if (key == LogicalKeyboardKey.arrowDown) {
      _moveFocus(1);
    } else if (key == LogicalKeyboardKey.arrowLeft) {
      _collapseOrMoveToParent();
    } else if (key == LogicalKeyboardKey.arrowRight) {
      _expandOrMoveToChild();
    } else if (key == LogicalKeyboardKey.enter || key == LogicalKeyboardKey.space) {
      _selectFocused();
    }
  }

  void _moveFocus(int delta) {
    setState(() {
      _focusedIndex = (_focusedIndex + delta).clamp(0, _flatList.length - 1);
      _scrollToFocused();
    });
  }

  void _scrollToFocused() {
    if (_flatList.isEmpty || !_scrollController.hasClients) return;

    final itemHeight = 28.0;
    final itemTop = _focusedIndex * itemHeight;
    final itemBottom = itemTop + itemHeight;
    final viewTop = _scrollController.offset;
    final viewBottom = viewTop + _scrollController.position.viewportDimension;

    // Only scroll if item is out of view
    if (itemTop < viewTop) {
      // Item is above viewport - scroll up
      _scrollController.jumpTo(itemTop);
    } else if (itemBottom > viewBottom) {
      // Item is below viewport - scroll down
      _scrollController.jumpTo(itemBottom - _scrollController.position.viewportDimension);
    }
  }

  void _collapseOrMoveToParent() {
    if (_flatList.isEmpty) return;
    final item = _flatList[_focusedIndex];

    if (item.isExpanded && item.hasChildren) {
      // Collapse this node
      setState(() {
        _expandedNodes.remove(item.key);
        _rebuildFlatList();
      });
    } else if (item.depth > 0) {
      // Move to parent
      for (int i = _focusedIndex - 1; i >= 0; i--) {
        if (_flatList[i].depth < item.depth) {
          setState(() => _focusedIndex = i);
          break;
        }
      }
    }
  }

  void _expandOrMoveToChild() {
    if (_flatList.isEmpty) return;
    final item = _flatList[_focusedIndex];

    if (item.hasChildren && !item.isExpanded) {
      // Expand this node
      setState(() {
        _expandedNodes.add(item.key);
        _rebuildFlatList();
      });
    } else if (item.hasChildren && item.isExpanded && _focusedIndex + 1 < _flatList.length) {
      // Move to first child
      setState(() => _focusedIndex++);
    }
  }

  void _selectFocused() {
    if (_flatList.isEmpty) return;
    widget.onSelect(_flatList[_focusedIndex].node);
  }

  void _toggleExpand(String key) {
    setState(() {
      if (_expandedNodes.contains(key)) {
        _expandedNodes.remove(key);
      } else {
        _expandedNodes.add(key);
      }
      _rebuildFlatList();
    });
  }

  @override
  Widget build(BuildContext context) {
    _rebuildFlatList(); // Rebuild on each render to sync with expanded state

    return Focus(
      focusNode: _focusNode,
      autofocus: false,
      onKeyEvent: (node, event) {
        if (event is! KeyDownEvent) return KeyEventResult.ignored;

        final key = event.logicalKey;
        if (key == LogicalKeyboardKey.arrowUp ||
            key == LogicalKeyboardKey.arrowDown ||
            key == LogicalKeyboardKey.arrowLeft ||
            key == LogicalKeyboardKey.arrowRight ||
            key == LogicalKeyboardKey.enter ||
            key == LogicalKeyboardKey.space) {
          _handleKeyEvent(event);
          return KeyEventResult.handled;
        }
        return KeyEventResult.ignored;
      },
      child: GestureDetector(
        onTap: () => _focusNode.requestFocus(),
        child: ListView.builder(
          controller: _scrollController,
          padding: EdgeInsets.zero,
          itemCount: _flatList.length,
          itemBuilder: (context, index) {
            final item = _flatList[index];
            final isFocused = index == _focusedIndex && _focusNode.hasFocus;

            return _LayerItemRow(
              item: item,
              isFocused: isFocused,
              onTap: () {
                setState(() => _focusedIndex = index);
                widget.onSelect(item.node);
                _focusNode.requestFocus();
              },
              onToggleExpand: item.hasChildren ? () => _toggleExpand(item.key) : null,
            );
          },
        ),
      ),
    );
  }
}

class _FlatLayerItem {
  final String key;
  final Map<String, dynamic> node;
  final int depth;
  final bool hasChildren;
  final bool isExpanded;

  _FlatLayerItem({
    required this.key,
    required this.node,
    required this.depth,
    required this.hasChildren,
    required this.isExpanded,
  });
}

class _LayerItemRow extends StatelessWidget {
  final _FlatLayerItem item;
  final bool isFocused;
  final VoidCallback onTap;
  final VoidCallback? onToggleExpand;

  const _LayerItemRow({
    required this.item,
    required this.isFocused,
    required this.onTap,
    this.onToggleExpand,
  });

  IconData _getIcon(String type) {
    switch (type) {
      case 'FRAME': return Icons.crop_square;
      case 'GROUP': return Icons.folder_outlined;
      case 'COMPONENT':
      case 'COMPONENT_SET': return Icons.widgets_outlined;
      case 'INSTANCE': return Icons.diamond_outlined;
      case 'TEXT': return Icons.text_fields;
      case 'RECTANGLE':
      case 'ROUNDED_RECTANGLE': return Icons.rectangle_outlined;
      case 'ELLIPSE': return Icons.circle_outlined;
      case 'VECTOR':
      case 'LINE': return Icons.show_chart;
      case 'SECTION': return Icons.view_agenda_outlined;
      default: return Icons.layers_outlined;
    }
  }

  @override
  Widget build(BuildContext context) {
    final name = item.node['name'] as String? ?? 'Unnamed';
    final type = item.node['type'] as String? ?? 'UNKNOWN';
    final nodeKey = item.node['_guidKey']?.toString();

    return ListenableBuilder(
      listenable: DebugOverlayController.instance,
      builder: (context, _) {
        final isSelected = DebugOverlayController.instance.selectedNode?['_guidKey'] == nodeKey;

        return GestureDetector(
          onTap: onTap,
          onDoubleTap: onToggleExpand,
          child: Container(
            height: 28,
            padding: EdgeInsets.only(left: 4 + item.depth * 12.0, right: 4),
            decoration: BoxDecoration(
              color: isSelected ? FigmaColors.accent : (isFocused ? FigmaColors.bg3 : Colors.transparent),
              border: isFocused && !isSelected ? Border.all(color: FigmaColors.accent, width: 1) : null,
            ),
            child: Row(
              children: [
                GestureDetector(
                  onTap: onToggleExpand,
                  child: SizedBox(
                    width: 16,
                    child: item.hasChildren
                        ? Icon(item.isExpanded ? Icons.expand_more : Icons.chevron_right, size: 12, color: FigmaColors.text3)
                        : null,
                  ),
                ),
                Icon(_getIcon(type), size: 12, color: isSelected ? FigmaColors.text1 : FigmaColors.text3),
                const SizedBox(width: 6),
                Expanded(
                  child: Text(
                    name,
                    style: TextStyle(color: isSelected ? FigmaColors.text1 : FigmaColors.text2, fontSize: 11),
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}

class _LayerItem extends StatefulWidget {
  final Map<String, dynamic> node;
  final Map<String, Map<String, dynamic>> nodeMap;
  final int depth;
  final void Function(Map<String, dynamic>) onSelect;

  const _LayerItem({required this.node, required this.nodeMap, required this.depth, required this.onSelect});

  @override
  State<_LayerItem> createState() => _LayerItemState();
}

class _LayerItemState extends State<_LayerItem> {
  bool _expanded = false;

  IconData _getIcon(String type) {
    switch (type) {
      case 'FRAME': return Icons.crop_square;
      case 'GROUP': return Icons.folder_outlined;
      case 'COMPONENT':
      case 'COMPONENT_SET': return Icons.widgets_outlined;
      case 'INSTANCE': return Icons.diamond_outlined;
      case 'TEXT': return Icons.text_fields;
      case 'RECTANGLE':
      case 'ROUNDED_RECTANGLE': return Icons.rectangle_outlined;
      case 'ELLIPSE': return Icons.circle_outlined;
      case 'VECTOR':
      case 'LINE': return Icons.show_chart;
      case 'SECTION': return Icons.view_agenda_outlined;
      default: return Icons.layers_outlined;
    }
  }

  @override
  Widget build(BuildContext context) {
    final name = widget.node['name'] as String? ?? 'Unnamed';
    final type = widget.node['type'] as String? ?? 'UNKNOWN';
    final children = widget.node['children'] as List? ?? [];
    final hasChildren = children.isNotEmpty;
    final nodeKey = widget.node['_guidKey']?.toString();

    return ListenableBuilder(
      listenable: DebugOverlayController.instance,
      builder: (context, _) {
        final isSelected = DebugOverlayController.instance.selectedNode?['_guidKey'] == nodeKey;

        return Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            GestureDetector(
              onTap: () => widget.onSelect(widget.node),
              onDoubleTap: hasChildren ? () => setState(() => _expanded = !_expanded) : null,
              child: Container(
                height: 28,
                padding: EdgeInsets.only(left: 4 + widget.depth * 12.0, right: 4),
                color: isSelected ? FigmaColors.accent : Colors.transparent,
                child: Row(
                  children: [
                    GestureDetector(
                      onTap: hasChildren ? () => setState(() => _expanded = !_expanded) : null,
                      child: SizedBox(
                        width: 16,
                        child: hasChildren
                            ? Icon(_expanded ? Icons.expand_more : Icons.chevron_right, size: 12, color: FigmaColors.text3)
                            : null,
                      ),
                    ),
                    Icon(_getIcon(type), size: 12, color: isSelected ? FigmaColors.text1 : FigmaColors.text3),
                    const SizedBox(width: 6),
                    Expanded(
                      child: Text(
                        name,
                        style: TextStyle(color: isSelected ? FigmaColors.text1 : FigmaColors.text2, fontSize: 11),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
              ),
            ),
            if (_expanded && hasChildren)
              ...children.map((childKey) {
                final childNode = widget.nodeMap[childKey.toString()];
                if (childNode == null) return const SizedBox.shrink();
                return _LayerItem(node: childNode, nodeMap: widget.nodeMap, depth: widget.depth + 1, onSelect: widget.onSelect);
              }),
          ],
        );
      },
    );
  }
}

class _SectionHeader extends StatelessWidget {
  final String title;
  const _SectionHeader({required this.title});

  @override
  Widget build(BuildContext context) {
    return Text(title, style: const TextStyle(color: FigmaColors.text1, fontSize: 11, fontWeight: FontWeight.w500));
  }
}

class _EditableInputField extends StatefulWidget {
  final String label;
  final String value;
  final ValueChanged<String>? onChanged;
  final bool enabled;

  const _EditableInputField({
    required this.label,
    required this.value,
    this.onChanged,
    this.enabled = true,
  });

  @override
  State<_EditableInputField> createState() => _EditableInputFieldState();
}

class _EditableInputFieldState extends State<_EditableInputField> {
  late TextEditingController _controller;
  bool _isFocused = false;

  @override
  void initState() {
    super.initState();
    _controller = TextEditingController(text: widget.value);
  }

  @override
  void didUpdateWidget(_EditableInputField oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.value != widget.value && !_isFocused) {
      _controller.text = widget.value;
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      height: 28,
      padding: const EdgeInsets.symmetric(horizontal: 8),
      decoration: BoxDecoration(
        color: FigmaColors.bg1,
        borderRadius: BorderRadius.circular(4),
        border: Border.all(color: _isFocused ? FigmaColors.accent : FigmaColors.border),
      ),
      child: Row(
        children: [
          Text(widget.label, style: const TextStyle(color: FigmaColors.text3, fontSize: 10)),
          const SizedBox(width: 8),
          Expanded(
            child: Focus(
              onFocusChange: (focused) => setState(() => _isFocused = focused),
              child: TextField(
                controller: _controller,
                enabled: widget.enabled,
                style: const TextStyle(color: FigmaColors.text1, fontSize: 11),
                textAlign: TextAlign.right,
                decoration: const InputDecoration(
                  border: InputBorder.none,
                  isDense: true,
                  contentPadding: EdgeInsets.zero,
                ),
                onSubmitted: widget.onChanged,
                onEditingComplete: () {
                  widget.onChanged?.call(_controller.text);
                },
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _InputField extends StatelessWidget {
  final String label;
  final String value;

  const _InputField({required this.label, required this.value});

  @override
  Widget build(BuildContext context) {
    return Container(
      height: 28,
      padding: const EdgeInsets.symmetric(horizontal: 8),
      decoration: BoxDecoration(
        color: FigmaColors.bg1,
        borderRadius: BorderRadius.circular(4),
        border: Border.all(color: FigmaColors.border),
      ),
      child: Row(
        children: [
          Text(label, style: const TextStyle(color: FigmaColors.text3, fontSize: 10)),
          const SizedBox(width: 8),
          Expanded(
            child: Text(value, style: const TextStyle(color: FigmaColors.text1, fontSize: 11), textAlign: TextAlign.right),
          ),
        ],
      ),
    );
  }
}

class _AlignButton extends StatelessWidget {
  final IconData icon;
  const _AlignButton({required this.icon});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(6),
      child: Icon(icon, size: 14, color: FigmaColors.text2),
    );
  }
}

class _FillItem extends StatelessWidget {
  final Map<String, dynamic> fill;
  const _FillItem({required this.fill});

  @override
  Widget build(BuildContext context) {
    final type = fill['type'] ?? 'UNKNOWN';
    Color? color;
    String label = type.toString();

    if (type == 'SOLID') {
      final c = fill['color'];
      if (c is Map) {
        color = Color.fromRGBO(
          ((c['r'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
          ((c['g'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
          ((c['b'] as num?)?.toDouble() ?? 0) * 255 ~/ 1,
          (c['a'] as num?)?.toDouble() ?? 1.0,
        );
        final hex = color.value.toRadixString(16).substring(2).toUpperCase();
        label = '#$hex';
      }
    } else if (type == 'IMAGE') {
      label = 'Image';
    }

    return Container(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        children: [
          Container(
            width: 20,
            height: 20,
            decoration: BoxDecoration(
              color: color ?? FigmaColors.bg3,
              borderRadius: BorderRadius.circular(4),
              border: Border.all(color: FigmaColors.border),
            ),
            child: type == 'IMAGE' ? const Icon(Icons.image, size: 12, color: FigmaColors.text2) : null,
          ),
          const SizedBox(width: 8),
          Expanded(child: Text(label, style: const TextStyle(color: FigmaColors.text1, fontSize: 11))),
          Icon(Icons.visibility_outlined, size: 14, color: FigmaColors.text3),
        ],
      ),
    );
  }
}

class _Divider extends StatelessWidget {
  const _Divider();

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.symmetric(vertical: 12),
      height: 1,
      color: FigmaColors.border,
    );
  }
}

/// Simple canvas widget without page selector (for embedding)
class FigmaSimpleCanvas extends StatelessWidget {
  final Map<String, dynamic> node;
  final Map<String, Map<String, dynamic>> nodeMap;
  final double scale;
  final bool showBounds;

  const FigmaSimpleCanvas({super.key, required this.node, required this.nodeMap, this.scale = 1.0, this.showBounds = false});

  @override
  Widget build(BuildContext context) {
    return InteractiveViewer(
      minScale: 0.1,
      maxScale: 10.0,
      boundaryMargin: const EdgeInsets.all(double.infinity),
      child: FigmaNodeWidget(node: node, nodeMap: nodeMap, scale: scale, showBounds: showBounds),
    );
  }
}

import 'dart:typed_data';
import 'dart:convert';

/// A byte buffer for reading and writing binary data with variable-length encoding.
class ByteBuffer {
  Uint8List _data;
  int _index = 0;
  int length = 0;

  /// Creates a new ByteBuffer, optionally initialized with data.
  ByteBuffer([Uint8List? data])
      : _data = data ?? Uint8List(256),
        length = data?.length ?? 0;

  /// Returns the buffer contents as a Uint8List.
  Uint8List toUint8Array() {
    return Uint8List.sublistView(_data, 0, length);
  }

  /// Reads a single byte from the buffer.
  int readByte() {
    if (_index + 1 > _data.length) {
      throw Exception('Index out of bounds');
    }
    return _data[_index++];
  }

  /// Reads a byte array with length prefix.
  Uint8List readByteArray() {
    int len = readVarUint();
    int start = _index;
    int end = start + len;
    if (end > _data.length) {
      throw Exception('Read array out of bounds');
    }
    _index = end;
    // Copy into a new array
    Uint8List result = Uint8List(len);
    result.setAll(0, _data.sublist(start, end));
    return result;
  }

  /// Reads a variable-length float.
  /// Zero is encoded as a single byte, non-zero values use 4 bytes
  /// with the exponent moved to the first 8 bits for better compression.
  double readVarFloat() {
    int index = _index;
    Uint8List data = _data;
    int len = data.length;

    // Optimization: use a single byte to store zero
    if (index + 1 > len) {
      throw Exception('Index out of bounds');
    }
    int first = data[index];
    if (first == 0) {
      _index = index + 1;
      return 0.0;
    }

    // Endian-independent 32-bit read
    if (index + 4 > len) {
      throw Exception('Index out of bounds');
    }
    int bits = first |
        (data[index + 1] << 8) |
        (data[index + 2] << 16) |
        (data[index + 3] << 24);
    _index = index + 4;

    // Ensure 32-bit value before shift operations
    bits = bits & 0xFFFFFFFF;

    // Move the exponent back into place (unsigned right shift simulation)
    bits = ((bits << 23) | ((bits & 0xFFFFFFFF) >>> 9)) & 0xFFFFFFFF;

    // Convert bits to float using Uint32 to handle sign correctly
    var byteData = ByteData(4);
    byteData.setUint32(0, bits, Endian.little);
    return byteData.getFloat32(0, Endian.little);
  }

  /// Reads a variable-length unsigned integer (up to 32 bits).
  /// Uses 7 bits per byte with a continuation bit.
  int readVarUint() {
    int value = 0;
    int shift = 0;
    int byte;
    do {
      byte = readByte();
      value |= (byte & 127) << shift;
      shift += 7;
    } while ((byte & 128) != 0 && shift < 35);
    return value & 0xFFFFFFFF; // Ensure unsigned
  }

  /// Reads a variable-length signed integer using zigzag encoding.
  int readVarInt() {
    int value = readVarUint();
    // Convert from unsigned to signed using zigzag decoding
    return (value & 1) != 0 ? ~(value >> 1) : (value >> 1);
  }

  /// Reads a variable-length unsigned 64-bit integer.
  /// Uses 7 bits per byte with a continuation bit.
  int readVarUint64() {
    int value = 0;
    int shift = 0;
    int byte;
    do {
      byte = readByte();
      value |= (byte & 127) << shift;
      shift += 7;
    } while ((byte & 128) != 0 && shift < 70);
    return value;
  }

  /// Reads a variable-length signed 64-bit integer using zigzag encoding.
  int readVarInt64() {
    int value = readVarUint64();
    // Convert from unsigned to signed using zigzag decoding
    return (value & 1) != 0 ? ~(value >> 1) : (value >> 1);
  }

  /// Reads a null-terminated UTF-8 string.
  String readString() {
    List<int> bytes = [];
    while (true) {
      int byte = readByte();
      if (byte == 0) break; // Null terminator
      bytes.add(byte);
    }
    return utf8.decode(bytes);
  }

  void _growBy(int amount) {
    if (length + amount > _data.length) {
      Uint8List newData = Uint8List((length + amount) << 1);
      newData.setAll(0, _data);
      _data = newData;
    }
    length += amount;
  }

  /// Writes a single byte to the buffer.
  void writeByte(int value) {
    int index = length;
    _growBy(1);
    _data[index] = value & 0xFF;
  }

  /// Writes a byte array with length prefix.
  void writeByteArray(Uint8List value) {
    writeVarUint(value.length);
    int index = length;
    _growBy(value.length);
    _data.setAll(index, value);
  }

  /// Writes a variable-length float.
  void writeVarFloat(double value) {
    int index = length;

    // Convert float to bits using Uint32 for correct bit representation
    var byteData = ByteData(4);
    byteData.setFloat32(0, value, Endian.little);
    int bits = byteData.getUint32(0, Endian.little);

    // Normalize NaN to positive quiet NaN (match JavaScript behavior)
    // JavaScript NaN is 0x7FC00000, Dart may produce 0xFFC00000
    if (value.isNaN) {
      bits = 0x7FC00000; // Positive quiet NaN
    }

    // Move the exponent to the first 8 bits (unsigned right shift)
    bits = (((bits & 0xFFFFFFFF) >>> 23) | (bits << 9)) & 0xFFFFFFFF;

    // Optimization: use a single byte to store zero and denormals
    if ((bits & 255) == 0) {
      writeByte(0);
      return;
    }

    // Endian-independent 32-bit write
    _growBy(4);
    _data[index] = bits & 0xFF;
    _data[index + 1] = (bits >> 8) & 0xFF;
    _data[index + 2] = (bits >> 16) & 0xFF;
    _data[index + 3] = (bits >> 24) & 0xFF;
  }

  /// Writes a variable-length unsigned integer.
  void writeVarUint(int value) {
    value = value & 0xFFFFFFFF; // Ensure unsigned
    do {
      int byte = value & 127;
      value = value >> 7;
      writeByte(value != 0 ? byte | 128 : byte);
    } while (value != 0);
  }

  /// Writes a variable-length signed integer using zigzag encoding.
  void writeVarInt(int value) {
    writeVarUint((value << 1) ^ (value >> 31));
  }

  /// Writes a variable-length unsigned 64-bit integer.
  void writeVarUint64(int value) {
    do {
      int byte = value & 127;
      value = value >> 7;
      writeByte(value != 0 ? byte | 128 : byte);
    } while (value != 0);
  }

  /// Writes a variable-length signed 64-bit integer using zigzag encoding.
  void writeVarInt64(int value) {
    writeVarUint64((value << 1) ^ (value >> 63));
  }

  /// Writes a null-terminated UTF-8 string.
  void writeString(String value) {
    List<int> bytes = utf8.encode(value);
    // Check for null character
    if (bytes.contains(0)) {
      throw Exception('Cannot encode a string containing the null character');
    }
    for (int byte in bytes) {
      writeByte(byte);
    }
    // Null terminator
    writeByte(0);
  }
}

import 'schema.dart';

/// Pretty-prints a schema back to text format.
String prettyPrintSchema(Schema schema) {
  var definitions = schema.definitions;
  StringBuffer text = StringBuffer();

  if (schema.package != null) {
    text.write('package ${schema.package};\n');
  }

  for (int i = 0; i < definitions.length; i++) {
    var definition = definitions[i];
    if (i > 0 || schema.package != null) text.write('\n');
    text.write('${definition.kind.name.toLowerCase()} ${definition.name} {\n');

    for (var field in definition.fields) {
      text.write('  ');
      if (definition.kind != DefinitionKind.ENUM) {
        text.write(field.type);
        if (field.isArray) {
          text.write('[]');
        }
        text.write(' ');
      }
      text.write(field.name);
      if (definition.kind != DefinitionKind.STRUCT) {
        text.write(' = ${field.value}');
      }
      if (field.isDeprecated) {
        text.write(' [deprecated]');
      }
      text.write(';\n');
    }

    text.write('}\n');
  }

  return text.toString();
}

