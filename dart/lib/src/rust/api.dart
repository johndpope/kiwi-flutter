// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `render_node_recursive`, `to_viewport`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`

/// Load a Figma file from bytes
Future<FigmaDocument> loadFigmaFile({required List<int> data}) =>
    RustLib.instance.api.crateApiLoadFigmaFile(data: data);

/// Get document metadata
Future<DocumentInfo> getDocumentInfo({required FigmaDocument doc}) =>
    RustLib.instance.api.crateApiGetDocumentInfo(doc: doc);

/// Get information about a specific node
Future<NodeInfo> getNodeInfo(
        {required FigmaDocument doc, required String nodeId}) =>
    RustLib.instance.api.crateApiGetNodeInfo(doc: doc, nodeId: nodeId);

/// Get all children of a node
Future<List<NodeInfo>> getChildren(
        {required FigmaDocument doc, required String nodeId}) =>
    RustLib.instance.api.crateApiGetChildren(doc: doc, nodeId: nodeId);

/// Get render commands for a node (and optionally its children)
Future<List<DrawCommand>> renderNode(
        {required FigmaDocument doc,
        required String nodeId,
        required bool includeChildren}) =>
    RustLib.instance.api.crateApiRenderNode(
        doc: doc, nodeId: nodeId, includeChildren: includeChildren);

/// Calculate layout for auto-layout frames
Future<List<LayoutResult>> calculateLayout(
        {required FigmaDocument doc, required String rootId}) =>
    RustLib.instance.api.crateApiCalculateLayout(doc: doc, rootId: rootId);

/// Export a node as SVG path data
Future<String> exportSvgPath(
        {required FigmaDocument doc, required String nodeId}) =>
    RustLib.instance.api.crateApiExportSvgPath(doc: doc, nodeId: nodeId);

/// Decode Kiwi-encoded fill paint data (matches Figma's JsKiwiSerialization_decodeFillPaintData)
Future<List<PaintInfo>> decodeFillPaint({required List<int> data}) =>
    RustLib.instance.api.crateApiDecodeFillPaint(data: data);

/// Decode Kiwi-encoded effect data
Future<List<EffectInfo>> decodeEffects({required List<int> data}) =>
    RustLib.instance.api.crateApiDecodeEffects(data: data);

/// Decode Kiwi-encoded vector data
Future<PathData> decodeVector({required List<int> data}) =>
    RustLib.instance.api.crateApiDecodeVector(data: data);

/// Initialize spatial index for a document (call once after loading)
Future<BigInt> initSpatialIndex(
        {required FigmaDocument doc, required String rootId}) =>
    RustLib.instance.api.crateApiInitSpatialIndex(doc: doc, rootId: rootId);

/// Get visible tile coordinates for a viewport
Future<List<TileCoordInfo>> getVisibleTiles(
        {required FigmaDocument doc, required ViewportInfo viewport}) =>
    RustLib.instance.api.crateApiGetVisibleTiles(doc: doc, viewport: viewport);

/// Render tiles visible in viewport
Future<List<TileRenderResult>> renderTiles(
        {required FigmaDocument doc,
        required String rootId,
        required ViewportInfo viewport}) =>
    RustLib.instance.api
        .crateApiRenderTiles(doc: doc, rootId: rootId, viewport: viewport);

/// Render a single tile by coordinates
Future<TileRenderResult> renderSingleTile(
        {required FigmaDocument doc,
        required String rootId,
        required TileCoordInfo coord}) =>
    RustLib.instance.api
        .crateApiRenderSingleTile(doc: doc, rootId: rootId, coord: coord);

/// Invalidate tiles for changed nodes
Future<List<TileCoordInfo>> invalidateTiles(
        {required FigmaDocument doc, required List<String> changedNodeIds}) =>
    RustLib.instance.api
        .crateApiInvalidateTiles(doc: doc, changedNodeIds: changedNodeIds);

/// Clear all cached tiles
Future<void> clearTileCache({required FigmaDocument doc}) =>
    RustLib.instance.api.crateApiClearTileCache(doc: doc);

/// Get tile cache statistics
Future<TileCacheStatsInfo> getTileCacheStats({required FigmaDocument doc}) =>
    RustLib.instance.api.crateApiGetTileCacheStats(doc: doc);

/// Get the fixed tile size constant
Future<double> getTileSize() => RustLib.instance.api.crateApiGetTileSize();

/// Query nodes at a point (for hit testing)
Future<List<String>> queryNodesAtPoint(
        {required FigmaDocument doc, required double x, required double y}) =>
    RustLib.instance.api.crateApiQueryNodesAtPoint(doc: doc, x: x, y: y);

/// Query nodes in a rectangular region
Future<List<String>> queryNodesInRect(
        {required FigmaDocument doc,
        required double minX,
        required double minY,
        required double maxX,
        required double maxY}) =>
    RustLib.instance.api.crateApiQueryNodesInRect(
        doc: doc, minX: minX, minY: minY, maxX: maxX, maxY: maxY);

/// Get overall document bounds from spatial index
Future<RectInfo?> getDocumentBounds({required FigmaDocument doc}) =>
    RustLib.instance.api.crateApiGetDocumentBounds(doc: doc);

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FigmaDocument>>
abstract class FigmaDocument implements RustOpaqueInterface {}

/// Color represented as RGBA (0-255)
class ColorInfo {
  final int r;
  final int g;
  final int b;
  final int a;

  const ColorInfo({
    required this.r,
    required this.g,
    required this.b,
    required this.a,
  });

  @override
  int get hashCode => r.hashCode ^ g.hashCode ^ b.hashCode ^ a.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ColorInfo &&
          runtimeType == other.runtimeType &&
          r == other.r &&
          g == other.g &&
          b == other.b &&
          a == other.a;
}

class DocumentInfo {
  final String name;
  final int version;
  final BigInt nodeCount;
  final List<String> pageIds;

  const DocumentInfo({
    required this.name,
    required this.version,
    required this.nodeCount,
    required this.pageIds,
  });

  @override
  int get hashCode =>
      name.hashCode ^ version.hashCode ^ nodeCount.hashCode ^ pageIds.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DocumentInfo &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          version == other.version &&
          nodeCount == other.nodeCount &&
          pageIds == other.pageIds;
}

/// Render command sent to Flutter for drawing
class DrawCommand {
  final String commandType;
  final PathData? path;
  final RectInfo? rect;
  final List<PaintInfo> fills;
  final List<PaintInfo> strokes;
  final double strokeWeight;
  final List<EffectInfo> effects;
  final TransformInfo transform;
  final PathData? clipPath;

  const DrawCommand({
    required this.commandType,
    this.path,
    this.rect,
    required this.fills,
    required this.strokes,
    required this.strokeWeight,
    required this.effects,
    required this.transform,
    this.clipPath,
  });

  @override
  int get hashCode =>
      commandType.hashCode ^
      path.hashCode ^
      rect.hashCode ^
      fills.hashCode ^
      strokes.hashCode ^
      strokeWeight.hashCode ^
      effects.hashCode ^
      transform.hashCode ^
      clipPath.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DrawCommand &&
          runtimeType == other.runtimeType &&
          commandType == other.commandType &&
          path == other.path &&
          rect == other.rect &&
          fills == other.fills &&
          strokes == other.strokes &&
          strokeWeight == other.strokeWeight &&
          effects == other.effects &&
          transform == other.transform &&
          clipPath == other.clipPath;
}

/// Effect information (shadows, blurs)
class EffectInfo {
  final String effectType;
  final bool visible;
  final double radius;
  final ColorInfo? color;
  final double offsetX;
  final double offsetY;
  final double spread;

  const EffectInfo({
    required this.effectType,
    required this.visible,
    required this.radius,
    this.color,
    required this.offsetX,
    required this.offsetY,
    required this.spread,
  });

  @override
  int get hashCode =>
      effectType.hashCode ^
      visible.hashCode ^
      radius.hashCode ^
      color.hashCode ^
      offsetX.hashCode ^
      offsetY.hashCode ^
      spread.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EffectInfo &&
          runtimeType == other.runtimeType &&
          effectType == other.effectType &&
          visible == other.visible &&
          radius == other.radius &&
          color == other.color &&
          offsetX == other.offsetX &&
          offsetY == other.offsetY &&
          spread == other.spread;
}

/// Gradient stop
class GradientStopInfo {
  final double position;
  final ColorInfo color;

  const GradientStopInfo({
    required this.position,
    required this.color,
  });

  @override
  int get hashCode => position.hashCode ^ color.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GradientStopInfo &&
          runtimeType == other.runtimeType &&
          position == other.position &&
          color == other.color;
}

class LayoutResult {
  final String nodeId;
  final double x;
  final double y;
  final double width;
  final double height;

  const LayoutResult({
    required this.nodeId,
    required this.x,
    required this.y,
    required this.width,
    required this.height,
  });

  @override
  int get hashCode =>
      nodeId.hashCode ^
      x.hashCode ^
      y.hashCode ^
      width.hashCode ^
      height.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LayoutResult &&
          runtimeType == other.runtimeType &&
          nodeId == other.nodeId &&
          x == other.x &&
          y == other.y &&
          width == other.width &&
          height == other.height;
}

/// Node information returned to Flutter
class NodeInfo {
  final String id;
  final String name;
  final String nodeType;
  final double x;
  final double y;
  final double width;
  final double height;
  final double rotation;
  final double opacity;
  final bool visible;
  final List<String> children;

  const NodeInfo({
    required this.id,
    required this.name,
    required this.nodeType,
    required this.x,
    required this.y,
    required this.width,
    required this.height,
    required this.rotation,
    required this.opacity,
    required this.visible,
    required this.children,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      name.hashCode ^
      nodeType.hashCode ^
      x.hashCode ^
      y.hashCode ^
      width.hashCode ^
      height.hashCode ^
      rotation.hashCode ^
      opacity.hashCode ^
      visible.hashCode ^
      children.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          nodeType == other.nodeType &&
          x == other.x &&
          y == other.y &&
          width == other.width &&
          height == other.height &&
          rotation == other.rotation &&
          opacity == other.opacity &&
          visible == other.visible &&
          children == other.children;
}

/// Paint information for fills/strokes
class PaintInfo {
  final String paintType;
  final ColorInfo? color;
  final List<GradientStopInfo> gradientStops;
  final double opacity;
  final String blendMode;

  const PaintInfo({
    required this.paintType,
    this.color,
    required this.gradientStops,
    required this.opacity,
    required this.blendMode,
  });

  @override
  int get hashCode =>
      paintType.hashCode ^
      color.hashCode ^
      gradientStops.hashCode ^
      opacity.hashCode ^
      blendMode.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PaintInfo &&
          runtimeType == other.runtimeType &&
          paintType == other.paintType &&
          color == other.color &&
          gradientStops == other.gradientStops &&
          opacity == other.opacity &&
          blendMode == other.blendMode;
}

/// Path data for vector rendering
class PathData {
  /// SVG-like path commands: M, L, C, Q, Z
  final String commands;
  final String fillRule;

  const PathData({
    required this.commands,
    required this.fillRule,
  });

  @override
  int get hashCode => commands.hashCode ^ fillRule.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PathData &&
          runtimeType == other.runtimeType &&
          commands == other.commands &&
          fillRule == other.fillRule;
}

/// Rectangle info
class RectInfo {
  final double x;
  final double y;
  final double width;
  final double height;
  final F64Array4 cornerRadii;

  const RectInfo({
    required this.x,
    required this.y,
    required this.width,
    required this.height,
    required this.cornerRadii,
  });

  @override
  int get hashCode =>
      x.hashCode ^
      y.hashCode ^
      width.hashCode ^
      height.hashCode ^
      cornerRadii.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RectInfo &&
          runtimeType == other.runtimeType &&
          x == other.x &&
          y == other.y &&
          width == other.width &&
          height == other.height &&
          cornerRadii == other.cornerRadii;
}

/// Cache statistics
class TileCacheStatsInfo {
  final BigInt cachedTiles;
  final BigInt maxTiles;
  final BigInt dirtyTiles;

  const TileCacheStatsInfo({
    required this.cachedTiles,
    required this.maxTiles,
    required this.dirtyTiles,
  });

  @override
  int get hashCode =>
      cachedTiles.hashCode ^ maxTiles.hashCode ^ dirtyTiles.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TileCacheStatsInfo &&
          runtimeType == other.runtimeType &&
          cachedTiles == other.cachedTiles &&
          maxTiles == other.maxTiles &&
          dirtyTiles == other.dirtyTiles;
}

/// Tile coordinate for Flutter (exposed to Flutter)
class TileCoordInfo {
  final int x;
  final int y;
  final int zoomLevel;

  const TileCoordInfo({
    required this.x,
    required this.y,
    required this.zoomLevel,
  });

  @override
  int get hashCode => x.hashCode ^ y.hashCode ^ zoomLevel.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TileCoordInfo &&
          runtimeType == other.runtimeType &&
          x == other.x &&
          y == other.y &&
          zoomLevel == other.zoomLevel;
}

/// Result of rendering a single tile
class TileRenderResult {
  final TileCoordInfo coord;
  final RectInfo bounds;
  final List<DrawCommand> commands;
  final BigInt nodeCount;
  final bool fromCache;

  const TileRenderResult({
    required this.coord,
    required this.bounds,
    required this.commands,
    required this.nodeCount,
    required this.fromCache,
  });

  @override
  int get hashCode =>
      coord.hashCode ^
      bounds.hashCode ^
      commands.hashCode ^
      nodeCount.hashCode ^
      fromCache.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TileRenderResult &&
          runtimeType == other.runtimeType &&
          coord == other.coord &&
          bounds == other.bounds &&
          commands == other.commands &&
          nodeCount == other.nodeCount &&
          fromCache == other.fromCache;
}

/// 2D affine transform matrix [a, b, c, d, tx, ty]
class TransformInfo {
  final double m00;
  final double m01;
  final double m02;
  final double m10;
  final double m11;
  final double m12;

  const TransformInfo({
    required this.m00,
    required this.m01,
    required this.m02,
    required this.m10,
    required this.m11,
    required this.m12,
  });

  static Future<TransformInfo> default_() =>
      RustLib.instance.api.crateApiTransformInfoDefault();

  @override
  int get hashCode =>
      m00.hashCode ^
      m01.hashCode ^
      m02.hashCode ^
      m10.hashCode ^
      m11.hashCode ^
      m12.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TransformInfo &&
          runtimeType == other.runtimeType &&
          m00 == other.m00 &&
          m01 == other.m01 &&
          m02 == other.m02 &&
          m10 == other.m10 &&
          m11 == other.m11 &&
          m12 == other.m12;
}

/// Viewport information for tile culling (exposed to Flutter)
class ViewportInfo {
  /// World-space X coordinate of viewport top-left
  final double x;

  /// World-space Y coordinate of viewport top-left
  final double y;

  /// Viewport width in world coordinates
  final double width;

  /// Viewport height in world coordinates
  final double height;

  /// Zoom scale (1.0 = 100%, 0.5 = 50%)
  final double scale;

  const ViewportInfo({
    required this.x,
    required this.y,
    required this.width,
    required this.height,
    required this.scale,
  });

  @override
  int get hashCode =>
      x.hashCode ^
      y.hashCode ^
      width.hashCode ^
      height.hashCode ^
      scale.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ViewportInfo &&
          runtimeType == other.runtimeType &&
          x == other.x &&
          y == other.y &&
          width == other.width &&
          height == other.height &&
          scale == other.scale;
}
