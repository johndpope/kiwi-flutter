/// Flutter integration for the Rust Figma Renderer
///
/// This file shows how to integrate the Rust WASM/FFI module with Flutter.
/// After running `flutter_rust_bridge_codegen generate`, the actual bindings
/// will be in `lib/src/rust/`.

import 'dart:typed_data';
import 'dart:ui' as ui;
import 'package:flutter/material.dart';

// These would be auto-generated by flutter_rust_bridge
// import 'package:figma_renderer/src/rust/api.dart';
// import 'package:figma_renderer/src/rust/frb_generated.dart';

/// Example of how the generated Dart API would be used
///
/// ```dart
/// // Initialize the Rust library (call once at app startup)
/// await RustLib.init();
///
/// // Load a Figma file
/// final bytes = await File('design.fig').readAsBytes();
/// final doc = await loadFigmaFile(data: bytes);
///
/// // Get document info
/// final info = await getDocumentInfo(doc: doc);
/// print('Loaded ${info.name} with ${info.nodeCount} nodes');
///
/// // Render a specific node
/// final commands = await renderNode(
///   doc: doc,
///   nodeId: 'some-node-id',
///   includeChildren: true,
/// );
///
/// // Use in a CustomPainter
/// CustomPaint(
///   painter: FigmaNodePainter(commands),
/// )
/// ```

/// Custom painter that renders Figma draw commands
class FigmaNodePainter extends CustomPainter {
  final List<DrawCommand> commands;

  FigmaNodePainter(this.commands);

  @override
  void paint(Canvas canvas, Size size) {
    for (final cmd in commands) {
      switch (cmd.commandType) {
        case 'rect':
          _paintRect(canvas, cmd);
          break;
        case 'ellipse':
          _paintEllipse(canvas, cmd);
          break;
        case 'path':
          _paintPath(canvas, cmd);
          break;
        case 'text':
          _paintText(canvas, cmd);
          break;
      }
    }
  }

  void _paintRect(Canvas canvas, DrawCommand cmd) {
    final rect = cmd.rect;
    if (rect == null) return;

    final rrect = RRect.fromRectAndCorners(
      Rect.fromLTWH(rect.x, rect.y, rect.width, rect.height),
      topLeft: Radius.circular(rect.cornerRadii[0]),
      topRight: Radius.circular(rect.cornerRadii[1]),
      bottomRight: Radius.circular(rect.cornerRadii[2]),
      bottomLeft: Radius.circular(rect.cornerRadii[3]),
    );

    // Apply effects (shadows)
    for (final effect in cmd.effects) {
      if (effect.effectType == 'drop_shadow' && effect.visible) {
        final shadowPaint = Paint()
          ..color = _colorFromInfo(effect.color).withOpacity(effect.color?.a ?? 255 / 255)
          ..maskFilter = MaskFilter.blur(BlurStyle.normal, effect.radius);

        canvas.save();
        canvas.translate(effect.offsetX, effect.offsetY);
        canvas.drawRRect(rrect, shadowPaint);
        canvas.restore();
      }
    }

    // Draw fills
    for (final fill in cmd.fills) {
      final paint = _paintFromInfo(fill);
      canvas.drawRRect(rrect, paint);
    }

    // Draw strokes
    for (final stroke in cmd.strokes) {
      final paint = _paintFromInfo(stroke)
        ..style = PaintingStyle.stroke
        ..strokeWidth = cmd.strokeWeight;
      canvas.drawRRect(rrect, paint);
    }
  }

  void _paintEllipse(Canvas canvas, DrawCommand cmd) {
    final rect = cmd.rect;
    if (rect == null) return;

    final ellipseRect = Rect.fromLTWH(rect.x, rect.y, rect.width, rect.height);

    // Draw fills
    for (final fill in cmd.fills) {
      final paint = _paintFromInfo(fill);
      canvas.drawOval(ellipseRect, paint);
    }

    // Draw strokes
    for (final stroke in cmd.strokes) {
      final paint = _paintFromInfo(stroke)
        ..style = PaintingStyle.stroke
        ..strokeWidth = cmd.strokeWeight;
      canvas.drawOval(ellipseRect, paint);
    }
  }

  void _paintPath(Canvas canvas, DrawCommand cmd) {
    final pathData = cmd.path;
    if (pathData == null || pathData.commands.isEmpty) return;

    final path = _parseSvgPath(pathData.commands);

    // Apply transform
    canvas.save();
    canvas.transform(Float64List.fromList([
      cmd.transform.m00, cmd.transform.m10, 0, 0,
      cmd.transform.m01, cmd.transform.m11, 0, 0,
      0, 0, 1, 0,
      cmd.transform.m02, cmd.transform.m12, 0, 1,
    ]));

    // Draw fills
    for (final fill in cmd.fills) {
      final paint = _paintFromInfo(fill);
      if (pathData.fillRule == 'evenodd') {
        path.fillType = ui.PathFillType.evenOdd;
      }
      canvas.drawPath(path, paint);
    }

    // Draw strokes
    for (final stroke in cmd.strokes) {
      final paint = _paintFromInfo(stroke)
        ..style = PaintingStyle.stroke
        ..strokeWidth = cmd.strokeWeight;
      canvas.drawPath(path, paint);
    }

    canvas.restore();
  }

  void _paintText(Canvas canvas, DrawCommand cmd) {
    // Text rendering would go here
    // This requires access to text data from the node
  }

  Paint _paintFromInfo(PaintInfo info) {
    final paint = Paint();

    switch (info.paintType) {
      case 'solid':
        if (info.color != null) {
          paint.color = _colorFromInfo(info.color);
        }
        break;

      case 'gradient_linear':
        if (info.gradientStops.isNotEmpty) {
          paint.shader = ui.Gradient.linear(
            Offset.zero,
            const Offset(1, 1), // Would need actual gradient handles
            info.gradientStops.map((s) => _colorFromInfo(s.color)).toList(),
            info.gradientStops.map((s) => s.position).toList(),
          );
        }
        break;

      case 'gradient_radial':
        if (info.gradientStops.isNotEmpty) {
          paint.shader = ui.Gradient.radial(
            const Offset(0.5, 0.5),
            0.5,
            info.gradientStops.map((s) => _colorFromInfo(s.color)).toList(),
            info.gradientStops.map((s) => s.position).toList(),
          );
        }
        break;
    }

    paint.blendMode = _blendModeFromString(info.blendMode);

    return paint;
  }

  Color _colorFromInfo(ColorInfo? info) {
    if (info == null) return Colors.black;
    return Color.fromARGB(info.a, info.r, info.g, info.b);
  }

  BlendMode _blendModeFromString(String mode) {
    switch (mode) {
      case 'MULTIPLY': return BlendMode.multiply;
      case 'SCREEN': return BlendMode.screen;
      case 'OVERLAY': return BlendMode.overlay;
      case 'DARKEN': return BlendMode.darken;
      case 'LIGHTEN': return BlendMode.lighten;
      case 'COLOR_DODGE': return BlendMode.colorDodge;
      case 'COLOR_BURN': return BlendMode.colorBurn;
      case 'HARD_LIGHT': return BlendMode.hardLight;
      case 'SOFT_LIGHT': return BlendMode.softLight;
      case 'DIFFERENCE': return BlendMode.difference;
      case 'EXCLUSION': return BlendMode.exclusion;
      case 'HUE': return BlendMode.hue;
      case 'SATURATION': return BlendMode.saturation;
      case 'COLOR': return BlendMode.color;
      case 'LUMINOSITY': return BlendMode.luminosity;
      default: return BlendMode.srcOver;
    }
  }

  ui.Path _parseSvgPath(String commands) {
    final path = ui.Path();
    final parts = commands.split(RegExp(r'(?=[MLCQZmlcqz])'));

    for (final part in parts) {
      if (part.isEmpty) continue;

      final cmd = part[0];
      final args = part.substring(1).trim().split(RegExp(r'[\s,]+'))
          .where((s) => s.isNotEmpty)
          .map((s) => double.tryParse(s) ?? 0.0)
          .toList();

      switch (cmd) {
        case 'M':
          if (args.length >= 2) path.moveTo(args[0], args[1]);
          break;
        case 'L':
          if (args.length >= 2) path.lineTo(args[0], args[1]);
          break;
        case 'C':
          if (args.length >= 6) {
            path.cubicTo(args[0], args[1], args[2], args[3], args[4], args[5]);
          }
          break;
        case 'Q':
          if (args.length >= 4) {
            path.quadraticBezierTo(args[0], args[1], args[2], args[3]);
          }
          break;
        case 'Z':
        case 'z':
          path.close();
          break;
      }
    }

    return path;
  }

  @override
  bool shouldRepaint(covariant FigmaNodePainter oldDelegate) {
    return commands != oldDelegate.commands;
  }
}

// =============================================================================
// Type stubs (would be auto-generated by flutter_rust_bridge)
// =============================================================================

class DrawCommand {
  final String commandType;
  final PathData? path;
  final RectInfo? rect;
  final List<PaintInfo> fills;
  final List<PaintInfo> strokes;
  final double strokeWeight;
  final List<EffectInfo> effects;
  final TransformInfo transform;

  DrawCommand({
    required this.commandType,
    this.path,
    this.rect,
    required this.fills,
    required this.strokes,
    required this.strokeWeight,
    required this.effects,
    required this.transform,
  });
}

class PathData {
  final String commands;
  final String fillRule;

  PathData({required this.commands, required this.fillRule});
}

class RectInfo {
  final double x, y, width, height;
  final List<double> cornerRadii;

  RectInfo({
    required this.x,
    required this.y,
    required this.width,
    required this.height,
    required this.cornerRadii,
  });
}

class PaintInfo {
  final String paintType;
  final ColorInfo? color;
  final List<GradientStopInfo> gradientStops;
  final double opacity;
  final String blendMode;

  PaintInfo({
    required this.paintType,
    this.color,
    required this.gradientStops,
    required this.opacity,
    required this.blendMode,
  });
}

class ColorInfo {
  final int r, g, b, a;

  ColorInfo({required this.r, required this.g, required this.b, required this.a});
}

class GradientStopInfo {
  final double position;
  final ColorInfo color;

  GradientStopInfo({required this.position, required this.color});
}

class EffectInfo {
  final String effectType;
  final bool visible;
  final double radius;
  final ColorInfo? color;
  final double offsetX, offsetY;
  final double spread;

  EffectInfo({
    required this.effectType,
    required this.visible,
    required this.radius,
    this.color,
    required this.offsetX,
    required this.offsetY,
    required this.spread,
  });
}

class TransformInfo {
  final double m00, m01, m02, m10, m11, m12;

  TransformInfo({
    required this.m00,
    required this.m01,
    required this.m02,
    required this.m10,
    required this.m11,
    required this.m12,
  });
}
